<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Meeting Transcript Analyzer</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/lodash.js/4.17.21/lodash.min.js"></script>
    <script>
        tailwind.config = {
            theme: {
                extend: {
                    colors: {
                        primary: '#5D5CDE',
                        secondary: '#4CAF50',
                        warning: '#FFC107',
                        danger: '#F44336',
                        accent: '#9C27B0'
                    }
                }
            },
            darkMode: 'class',
        }
    </script>
</head>
<body class="bg-white dark:bg-gray-900 text-gray-900 dark:text-gray-100 transition-colors duration-200">
    <div class="container mx-auto p-4 max-w-6xl">
        <header class="mb-8">
            <h1 class="text-3xl font-bold text-primary mb-2">Meeting Transcript Analyzer</h1>
            <p class="text-gray-600 dark:text-gray-400">Advanced analysis and visualization of meeting transcripts</p>
        </header>
        
        <section id="input-section" class="mb-8">
            <h2 class="text-xl font-semibold mb-4">Input Meeting Transcript</h2>
            <div class="flex flex-col space-y-4">
                <textarea id="textInput" placeholder="Paste your meeting transcript here..." class="w-full p-3 border rounded-lg text-base dark:bg-gray-800 dark:border-gray-700 h-60 focus:border-primary focus:ring-1 focus:ring-primary transition-all duration-200"></textarea>
                
                <div class="flex flex-col sm:flex-row items-start sm:items-center gap-4">
                    <div class="relative">
                        <input type="file" id="fileInput" accept=".txt" class="absolute inset-0 opacity-0 w-full cursor-pointer" multiple>
                        <button class="bg-primary hover:bg-primary/90 text-white font-medium py-2 px-4 rounded transition-colors duration-200">
                            Upload Transcript Files
                        </button>
                    </div>
                    <span id="fileNames" class="text-sm text-gray-600 dark:text-gray-400"></span>
                </div>
            </div>
        </section>
        
        <section id="action-section" class="flex flex-wrap gap-4 mb-8">
            <button id="analyzeBtn" class="bg-primary hover:bg-primary/90 text-white font-medium py-2 px-6 rounded transition-colors duration-200">
                Analyze Transcript
            </button>
            
            <button id="clearBtn" class="bg-gray-200 hover:bg-gray-300 dark:bg-gray-700 dark:hover:bg-gray-600 text-gray-800 dark:text-gray-200 font-medium py-2 px-6 rounded transition-colors duration-200">
                Clear All
            </button>
            
            <button id="themeToggleBtn" class="ml-auto bg-gray-200 hover:bg-gray-300 dark:bg-gray-700 dark:hover:bg-gray-600 text-gray-800 dark:text-gray-200 font-medium py-2 px-4 rounded flex items-center transition-colors duration-200">
                <span id="themeIcon">🌙</span>
                <span class="ml-2" id="themeText">Dark Mode</span>
            </button>
        </section>

        <div id="loading" class="hidden">
            <div class="flex items-center justify-center p-6">
                <div class="animate-spin rounded-full h-12 w-12 border-t-2 border-b-2 border-primary"></div>
                <span class="ml-3 text-lg">Analyzing transcript...</span>
            </div>
        </div>
        
        <section id="results" class="hidden space-y-8">
            <!-- Meeting Metadata -->
            <div class="border dark:border-gray-700 rounded-lg overflow-hidden shadow-sm">
                <div class="bg-gray-100 dark:bg-gray-800 px-4 py-3 font-semibold border-b dark:border-gray-700">Meeting Information</div>
                <div id="meetingInfo" class="p-4"></div>
            </div>

            <!-- Tabs for different analysis views -->
            <div class="border dark:border-gray-700 rounded-lg overflow-hidden shadow-sm">
                <div class="border-b dark:border-gray-700">
                    <nav class="flex flex-wrap">
                        <button data-tab="Timeline" class="tab-button px-4 py-3 text-sm font-medium border-b-2 border-primary">Timeline View</button>
                        <button data-tab="Keywords" class="tab-button px-4 py-3 text-sm font-medium border-b-2 border-transparent">Keyword Analysis</button>
                        <button data-tab="Sentiment" class="tab-button px-4 py-3 text-sm font-medium border-b-2 border-transparent">Sentiment Analysis</button>
                        <button data-tab="Topics" class="tab-button px-4 py-3 text-sm font-medium border-b-2 border-transparent">Topic Clusters</button>
                    </nav>
                </div>
                
                <!-- Timeline View Tab Content -->
                <div id="contentTimeline" class="tab-content p-4">
                    <div id="timelineContent" class="space-y-4"></div>
                </div>
                
                <!-- Keyword Analysis Tab Content -->
                <div id="contentKeywords" class="tab-content p-4 hidden">
                    <div class="grid grid-cols-1 md:grid-cols-2 gap-6">
                        <div>
                            <h3 class="text-lg font-medium mb-3">Key Terms Frequency</h3>
                            <div class="h-80">
                                <canvas id="keywordsChart"></canvas>
                            </div>
                        </div>
                        <div>
                            <h3 class="text-lg font-medium mb-3">Word Cloud</h3>
                            <div id="wordCloudContainer" class="h-80 border rounded-lg p-4 flex items-center justify-center">
                                <div id="wordCloud" class="w-full h-full overflow-auto"></div>
                            </div>
                        </div>
                    </div>
                    <div class="mt-6">
                        <h3 class="text-lg font-medium mb-3">Term Context</h3>
                        <div class="overflow-auto max-h-80">
                            <table class="min-w-full divide-y divide-gray-200 dark:divide-gray-700">
                                <thead class="bg-gray-50 dark:bg-gray-800">
                                    <tr>
                                        <th class="px-4 py-2 text-left text-xs font-medium text-gray-500 dark:text-gray-400 uppercase tracking-wider">Term</th>
                                        <th class="px-4 py-2 text-left text-xs font-medium text-gray-500 dark:text-gray-400 uppercase tracking-wider">Frequency</th>
                                        <th class="px-4 py-2 text-left text-xs font-medium text-gray-500 dark:text-gray-400 uppercase tracking-wider">Context Examples</th>
                                    </tr>
                                </thead>
                                <tbody id="termContextTable" class="bg-white dark:bg-gray-900 divide-y divide-gray-200 dark:divide-gray-700"></tbody>
                            </table>
                        </div>
                    </div>
                </div>
                
                <!-- Sentiment Analysis Tab Content -->
                <div id="contentSentiment" class="tab-content p-4 hidden">
                    <div class="grid grid-cols-1 md:grid-cols-2 gap-6">
                        <div>
                            <h3 class="text-lg font-medium mb-3">Overall Sentiment</h3>
                            <div class="h-80">
                                <canvas id="sentimentChart"></canvas>
                            </div>
                        </div>
                        <div>
                            <h3 class="text-lg font-medium mb-3">Sentiment Timeline</h3>
                            <div class="h-80">
                                <canvas id="sentimentTimelineChart"></canvas>
                            </div>
                        </div>
                    </div>
                    <div class="mt-6">
                        <h3 class="text-lg font-medium mb-3">Emotional Tone Analysis</h3>
                        <div id="emotionalToneAnalysis" class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4"></div>
                    </div>
                </div>
                
                <!-- Topic Clusters Tab Content -->
                <div id="contentTopics" class="tab-content p-4 hidden">
                    <div class="grid grid-cols-1 lg:grid-cols-2 gap-6">
                        <div>
                            <h3 class="text-lg font-medium mb-3">Main Discussion Topics</h3>
                            <div class="h-80">
                                <canvas id="topicsChart"></canvas>
                            </div>
                        </div>
                        <div>
                            <h3 class="text-lg font-medium mb-3">Topic Relationships</h3>
                            <div id="topicRelationships" class="h-80 border rounded-lg p-4 flex items-center justify-center bg-white dark:bg-gray-800">
                                <div id="topicNetwork" class="w-full h-full"></div>
                            </div>
                        </div>
                    </div>
                    <div class="mt-6">
                        <h3 class="text-lg font-medium mb-3">Topic Details</h3>
                        <div id="topicDetails" class="space-y-4"></div>
                    </div>
                </div>
            </div>

            <div class="flex justify-end gap-4">
                <button id="downloadBtn" class="bg-primary hover:bg-primary/90 text-white font-medium py-2 px-4 rounded transition-colors duration-200">
                    Download Analysis
                </button>
                <button id="copyReportBtn" class="bg-gray-200 hover:bg-gray-300 dark:bg-gray-700 dark:hover:bg-gray-600 text-gray-800 dark:text-gray-200 font-medium py-2 px-4 rounded transition-colors duration-200">
                    Copy Summary Report
                </button>
            </div>
        </section>
    </div>

    <script>
        /**
         * Transcript Analyzer - Core Application
         * Advanced meeting transcript analysis system with enhanced performance and UX
         */
        
        // ======== Application State Management ========
        const AppState = {
            transcripts: [],
            analysis: null,
            charts: {},
            darkMode: false,

            // Defined key terms for analysis
            keyTerms: {
                professional: 0,
                professionals: 0,
                parent: 0,
                parents: 0,
                partner: 0,
                partners: 0,
                partnership: 0,
                practice: 0
            },
            
            // Sentiment analysis word lists
            wordLists: {
                positive: ["good", "great", "excellent", "happy", "positive", "love", "best", "amazing", 
                          "wonderful", "success", "beautiful", "joy", "partnership", "partners", 
                          "together", "streamlined", "able", "effective", "efficient", "innovative"],
                
                negative: ["bad", "terrible", "worst", "hate", "negative", "poor", "awful", "horrible", 
                          "failure", "sad", "wrong", "disaster", "fair", "armed", "emotionally", 
                          "unstable", "difficult", "problem", "issue", "concern"]
            },
            
            // Topic definitions
            topicDefinitions: [
                {
                    name: "Professional-Parent Relationship",
                    keywords: ["professional", "professionals", "parent", "parents", "relationship"],
                    color: "#4CAF50"
                },
                {
                    name: "Partnership Model",
                    keywords: ["partner", "partners", "partnership", "together", "pilot"],
                    color: "#FFC107"
                },
                {
                    name: "Practice & Training",
                    keywords: ["practice", "training", "trained", "language", "speak", "teach"],
                    color: "#9C27B0"
                },
                {
                    name: "Challenges & Issues",
                    keywords: ["fair", "dealing", "armed", "emotionally", "unstable"],
                    color: "#F44336"
                }
            ],
            
            // Emotional tone definitions
            emotionalTones: {
                'Collaborative': ['partnership', 'partners', 'together', 'working', 'cooperation', 'joint'],
                'Instructional': ['teach', 'language', 'learn', 'training', 'demonstrate', 'explain'],
                'Concerned': ['fair', 'dealing', 'armed', 'emotionally', 'unstable', 'worried'],
                'Structured': ['practice', 'pilot', 'program', 'system', 'process', 'framework']
            },
            
            reset() {
                this.transcripts = [];
                this.analysis = null;
                // Destroy existing charts
                Object.values(this.charts).forEach(chart => {
                    if (chart && typeof chart.destroy === 'function') {
                        chart.destroy();
                    }
                });
                this.charts = {};
                
                // Reset key terms
                Object.keys(this.keyTerms).forEach(key => {
                    this.keyTerms[key] = 0;
                });
            }
        };

        // ======== DOM Elements ========
        const DOM = {
            textInput: document.getElementById('textInput'),
            fileInput: document.getElementById('fileInput'),
            fileNames: document.getElementById('fileNames'),
            analyzeBtn: document.getElementById('analyzeBtn'),
            clearBtn: document.getElementById('clearBtn'),
            themeToggleBtn: document.getElementById('themeToggleBtn'),
            themeIcon: document.getElementById('themeIcon'),
            themeText: document.getElementById('themeText'),
            loading: document.getElementById('loading'),
            results: document.getElementById('results'),
            meetingInfo: document.getElementById('meetingInfo'),
            timelineContent: document.getElementById('timelineContent'),
            termContextTable: document.getElementById('termContextTable'),
            downloadBtn: document.getElementById('downloadBtn'),
            copyReportBtn: document.getElementById('copyReportBtn'),
            
            // Tab elements
            tabButtons: document.querySelectorAll('.tab-button'),
            tabContents: document.querySelectorAll('.tab-content'),
            
            // Canvas contexts (loaded on demand)
            canvasContexts: {},
            
            // Method to get canvas context
            getCanvasContext(id) {
                if (!this.canvasContexts[id]) {
                    const canvas = document.getElementById(id);
                    if (canvas) {
                        this.canvasContexts[id] = canvas.getContext('2d');
                    }
                }
                return this.canvasContexts[id];
            }
        };

        // ======== Event Handlers ========
        const EventHandlers = {
            init() {
                // Initialize event listeners
                DOM.fileInput.addEventListener('change', this.handleFileUpload);
                DOM.analyzeBtn.addEventListener('click', this.analyzeTranscript);
                DOM.clearBtn.addEventListener('click', this.clearAll);
                DOM.downloadBtn.addEventListener('click', this.downloadAnalysis);
                DOM.copyReportBtn.addEventListener('click', this.copyReport);
                DOM.themeToggleBtn.addEventListener('click', this.toggleTheme);
                
                // Tab event listeners
                DOM.tabButtons.forEach(button => {
                    button.addEventListener('click', () => {
                        const tabName = button.getAttribute('data-tab');
                        this.switchTab(tabName);
                    });
                });
                
                // Initialize theme based on system preference
                this.initTheme();
            },
            
            async handleFileUpload(event) {
                const files = event.target.files;
                if (!files.length) return;
                
                const fileNamesList = [];
                AppState.transcripts = [];
                
                for (const file of files) {
                    fileNamesList.push(file.name);
                    
                    try {
                        const text = await FileProcessor.readFileContent(file);
                        AppState.transcripts.push({
                            source: file.name,
                            content: text
                        });
                    } catch (error) {
                        console.error('Error reading file:', error);
                        UIController.showNotification('Error reading file: ' + file.name, 'error');
                    }
                }
                
                DOM.fileNames.textContent = fileNamesList.join(', ');
                
                // If textarea is empty, show first file content as preview
                if (!DOM.textInput.value && AppState.transcripts.length > 0) {
                    DOM.textInput.value = AppState.transcripts[0].content;
                }
            },
            
            async analyzeTranscript() {
                const inputText = DOM.textInput.value.trim();
                
                // Add manual input to transcripts if not already included
                if (inputText && AppState.transcripts.length === 0) {
                     AppState.transcripts = [{ source: 'Manual Input', content: inputText }];
                } else if (inputText && !AppState.transcripts.find(t => t.source === 'Manual Input' && t.content === inputText)) {
                    // If files were uploaded AND text area has different content, add it.
                    // This logic might need refinement based on desired behavior if both exist.
                    // For now, if text input is primary and files are supplemental, or vice versa.
                    // Let's assume if text input is present, it's the main one unless files are also there.
                    // A simple approach: if textarea has content and no files were loaded, use textarea.
                    // If files were loaded, they are primary. If text area has *additional* content, it's harder.
                    // The original logic: if inputText and transcripts empty, add. This is clear.
                    // Let's stick to: if files are loaded, they are `AppState.transcripts`.
                    // If textarea has text, and no files were loaded, then that text becomes a transcript.
                    // If files are loaded, and textarea also has text, we assume the files are primary.
                    // The current logic: `if (inputText && AppState.transcripts.length === 0)` is fine.
                }
                
                if (AppState.transcripts.length === 0 && !inputText) { // Ensure this check is after potential manual input add
                    UIController.showNotification('Please enter a transcript or upload a file to analyze', 'warning');
                    return;
                }
                
                // Show loading state
                UIController.setLoadingState(true);
                
                // Use requestAnimationFrame to allow UI to update before processing
                requestAnimationFrame(async () => {
                    try {
                        // Get current transcripts for analysis
                        let transcriptsToAnalyze = AppState.transcripts;
                        if (transcriptsToAnalyze.length === 0 && inputText) {
                             transcriptsToAnalyze = [{ source: 'Manual Input', content: inputText }];
                        }
                        
                        // Parse the transcript and perform analysis
                        AppState.analysis = await TranscriptAnalyzer.analyzeTranscripts(transcriptsToAnalyze);
                        
                        // Display meeting metadata
                        UIController.displayMeetingInfo(AppState.analysis);
                        
                        // Render timeline view (default active tab)
                        UIController.renderTimelineView(AppState.analysis);
                        // Ensure the timeline tab is active
                        this.switchTab('Timeline');

                        // Show results
                        UIController.setLoadingState(false);
                    } catch (error) {
                        console.error('Error analyzing transcript:', error);
                        UIController.setLoadingState(false);
                        UIController.showNotification('Error analyzing transcript: ' + error.message, 'error');
                    }
                });
            },
            
            switchTab(tabName) {
                // Update tab buttons
                DOM.tabButtons.forEach(button => {
                    const isActive = button.getAttribute('data-tab') === tabName;
                    button.classList.toggle('border-primary', isActive);
                    button.classList.toggle('text-primary', isActive); // Make active tab text primary color
                    button.classList.toggle('border-transparent', !isActive);
                     button.classList.toggle('text-gray-600', !isActive && !AppState.darkMode);
                    button.classList.toggle('dark:text-gray-400', !isActive && AppState.darkMode);


                });
                
                // Update tab contents
                DOM.tabContents.forEach(content => {
                    const contentId = `content${tabName}`;
                    content.classList.toggle('hidden', content.id !== contentId);
                });
                
                // Render content for the selected tab if analysis exists
                if (AppState.analysis) {
                    switch (tabName) {
                        case 'Keywords':
                            UIController.renderKeywordAnalysis();
                            break;
                        case 'Sentiment':
                            UIController.renderSentimentAnalysis();
                            break;
                        case 'Topics':
                            UIController.renderTopicAnalysis();
                            break;
                        // Timeline is rendered on analysis, no specific action here unless re-render needed.
                    }
                }
            },
            
            clearAll() {
                DOM.textInput.value = '';
                DOM.fileInput.value = ''; // Resets the file input
                DOM.fileNames.textContent = '';
                AppState.reset();
                DOM.results.classList.add('hidden');
                // Clear content of all tabs
                DOM.timelineContent.innerHTML = '';
                if (DOM.getCanvasContext('keywordsChart') && AppState.charts.keywords) AppState.charts.keywords.destroy();
                if (DOM.getCanvasContext('sentimentChart') && AppState.charts.sentiment) AppState.charts.sentiment.destroy();
                if (DOM.getCanvasContext('sentimentTimelineChart') && AppState.charts.sentimentTimeline) AppState.charts.sentimentTimeline.destroy();
                if (DOM.getCanvasContext('topicsChart') && AppState.charts.topics) AppState.charts.topics.destroy();
                document.getElementById('wordCloud').innerHTML = '';
                document.getElementById('termContextTable').innerHTML = '';
                document.getElementById('emotionalToneAnalysis').innerHTML = '';
                document.getElementById('topicNetwork').innerHTML = '';
                document.getElementById('topicDetails').innerHTML = '';

                UIController.showNotification('All data cleared', 'info');
            },
            
            downloadAnalysis() {
                if (!AppState.analysis) return;
                
                DataExporter.downloadAnalysisJSON(AppState.analysis);
                UIController.showNotification('Analysis downloaded', 'success');
            },
            
            copyReport() {
                if (!AppState.analysis) return;
                
                const report = DataExporter.generateTextReport(AppState.analysis);
                navigator.clipboard.writeText(report)
                    .then(() => UIController.showNotification('Report copied to clipboard', 'success'))
                    .catch(err => UIController.showNotification('Failed to copy: ' + err, 'error'));
            },
            
            initTheme() {
                const storedTheme = localStorage.getItem('theme');
                if (storedTheme === 'dark') {
                    this.setDarkMode(true);
                } else if (storedTheme === 'light') {
                    this.setDarkMode(false);
                } else {
                     // Check for system preference if no stored theme
                    const prefersDark = window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches;
                    this.setDarkMode(prefersDark);
                }
                
                // Listen for system preference changes if no theme is manually set
                window.matchMedia('(prefers-color-scheme: dark)').addEventListener('change', event => {
                    if (!localStorage.getItem('theme')) { // Only apply if user hasn't set a theme
                       this.setDarkMode(event.matches);
                    }
                });
            },
            
            toggleTheme() {
                this.setDarkMode(!AppState.darkMode);
            },
            
            setDarkMode(isDark) {
                AppState.darkMode = isDark;
                localStorage.setItem('theme', isDark ? 'dark' : 'light');
                document.documentElement.classList.toggle('dark', isDark);
                DOM.themeIcon.textContent = isDark ? '☀️' : '🌙';
                DOM.themeText.textContent = isDark ? 'Light Mode' : 'Dark Mode';
                
                // Re-render charts if they exist and results are visible
                if (AppState.analysis && !DOM.results.classList.contains('hidden')) {
                    const activeTab = Array.from(DOM.tabButtons).find(button => button.classList.contains('border-primary'));
                    if (activeTab) {
                        const activeTabName = activeTab.getAttribute('data-tab');
                        // Re-render the content of the currently active tab that involves charts
                        if (activeTabName === 'Keywords') UIController.renderKeywordAnalysis();
                        if (activeTabName === 'Sentiment') UIController.renderSentimentAnalysis();
                        if (activeTabName === 'Topics') UIController.renderTopicAnalysis();
                        // Timeline and MeetingInfo typically don't need chart re-renders for theme, but if they had theme-dependent styles beyond Tailwind, they would.
                    }
                }
            }
        };

        // ======== File Processing Module ========
        const FileProcessor = {
            async readFileContent(file) {
                return new Promise((resolve, reject) => {
                    const reader = new FileReader();
                    reader.onload = event => resolve(event.target.result);
                    reader.onerror = error => reject(error);
                    reader.readAsText(file);
                });
            }
        };

        // ======== Transcript Analysis Module ========
        const TranscriptAnalyzer = {
            async analyzeTranscripts(transcripts) {
                const analysis = {
                    meetings: [],
                    combinedSegments: [],
                    keyTerms: { ...AppState.keyTerms }, // Initialize with 0 counts
                    termContexts: {},
                    wordFrequency: {},
                    sentiment: {
                        positive: 0,
                        negative: 0,
                        neutral: 0
                    },
                    topicClusters: []
                };
                
                // Reset key term counts explicitly for each analysis run
                Object.keys(analysis.keyTerms).forEach(term => {
                    analysis.keyTerms[term] = 0;
                    analysis.termContexts[term] = []; // Ensure context array is initialized
                });
                
                const processedResults = await Promise.all(
                    transcripts.map(transcript => this.processTranscript(transcript, analysis))
                );
                
                processedResults.forEach(result => {
                    if (result.parsedMeeting) {
                        analysis.meetings.push(result.parsedMeeting);
                        analysis.combinedSegments.push(...result.segments);
                    } else if (result.segments.length > 0) { // Handle cases where no meeting info but segments exist
                        analysis.combinedSegments.push(...result.segments);
                         if (analysis.meetings.length === 0) { // Add a default meeting if none parsed
                            analysis.meetings.push({ title: "General Transcript", type: "General", participants: [] });
                        }
                    }
                });
                
                analysis.combinedSegments.sort((a, b) => {
                    if (a.timestampSeconds !== null && b.timestampSeconds !== null) {
                        return a.timestampSeconds - b.timestampSeconds;
                    }
                    return 0; // Keep original order if timestamps are missing/invalid
                });
                
                analysis.topicClusters = this.generateTopicClusters(analysis);
                
                return analysis;
            },
            
            async processTranscript(transcript, analysis) { // Pass the main analysis object to accumulate counts
                const { parsedMeeting, segments } = this.parseTranscript(transcript.content);
                
                segments.forEach(segment => {
                    segment.source = transcript.source;
                    if (parsedMeeting) segment.meetingTitle = parsedMeeting.title;
                    
                    this.processTextForKeywords(segment.text, analysis); // Modifies analysis.keyTerms and analysis.wordFrequency
                    
                    segment.sentiment = this.analyzeSentiment(segment.text);
                    analysis.sentiment[segment.sentiment]++; // Modifies analysis.sentiment
                });
                
                return { parsedMeeting, segments };
            },
            
            parseTranscript(text) {
                const lines = text.split('\n').filter(line => line.trim() !== '');
                let meetingInfo = null;
                const segments = [];
                
                if (lines.length > 0) {
                    const titleMatch = lines[0].match(/(.+) Meeting with (.+)/i); // Case-insensitive title match
                    if (titleMatch && titleMatch.length >= 3) {
                        meetingInfo = {
                            title: titleMatch[0].trim(),
                            type: titleMatch[1]?.trim() || 'General',
                            participants: titleMatch[2]?.split(',').map(p => p.trim()) || []
                        };
                        if (lines.length > 1) {
                            const dateMatch = lines[1].match(/([A-Za-z]+)\s+(\d{1,2}),\s+\d{4}\s+(\d{1,2}:\d{2})\s+([AP]M)\s+-\s+(.+)/i); // More specific date match
                            if (dateMatch) {
                                meetingInfo.date = lines[1].trim();
                            }
                        }
                    } else {
                         meetingInfo = { title: "Transcript Analysis", type: "General", participants: [] };
                    }
                } else {
                     meetingInfo = { title: "Transcript Analysis", type: "General", participants: [] };
                }
                
                const timestampPatterns = [
                    /^\.\.\.\s+(.+?)\s+(\d{1,2}:\d{2}(:\d{2})?)$/, // "... Speaker text 00:00" or "00:00:00"
                    /^\[(\d{1,2}:\d{2}(:\d{2})?)\]\s*(?:(.+?):)?\s*(.+)$/, // "[00:00] Speaker: text" or "[00:00] text"
                    /^(?:(.+?)\s+)?\((\d{1,2}:\d{2}(:\d{2})?)\):\s*(.+)$/, // "Speaker (00:00): text" or "(00:00): text"
                    /^(\d{1,2}:\d{2}(:\d{2})?)\s*(?:(.+?):)?\s*(.+)$/  // "00:00 Speaker: text" or "00:00 text"
                ];
                
                for (let i = 0; i < lines.length; i++) {
                    const line = lines[i].trim();
                    if (meetingInfo && (line === meetingInfo.title || line === meetingInfo.date)) continue; // Skip metadata lines

                    let matched = false;
                    for (const pattern of timestampPatterns) {
                        const match = line.match(pattern);
                        if (match) {
                            let textContent, timestamp, speaker;
                            
                            if (pattern === timestampPatterns[0]) { // "... Speaker text 00:00"
                                textContent = match[1].trim();
                                timestamp = match[2].trim();
                            } else if (pattern === timestampPatterns[1]) { // "[00:00] Speaker: text"
                                timestamp = match[1].trim();
                                speaker = match[3]?.trim();
                                textContent = match[4].trim();
                                if (speaker) textContent = `${speaker}: ${textContent}`;
                            } else if (pattern === timestampPatterns[2]) { // "Speaker (00:00): text"
                                speaker = match[1]?.trim();
                                timestamp = match[2].trim();
                                textContent = match[4].trim();
                                if (speaker) textContent = `${speaker}: ${textContent}`; else textContent = textContent;
                            } else if (pattern === timestampPatterns[3]) { // "00:00 Speaker: text"
                                timestamp = match[1].trim();
                                speaker = match[3]?.trim();
                                textContent = match[4].trim();
                                if (speaker) textContent = `${speaker}: ${textContent}`;
                            }
                            
                            const timestampParts = timestamp.split(':');
                            let timestampSeconds = null;
                            if (timestampParts.length === 2) {
                                timestampSeconds = parseInt(timestampParts[0]) * 60 + parseInt(timestampParts[1]);
                            } else if (timestampParts.length === 3) {
                                timestampSeconds = parseInt(timestampParts[0]) * 3600 + parseInt(timestampParts[1]) * 60 + parseInt(timestampParts[2]);
                            }
                            
                            if (textContent) {
                                segments.push({
                                    text: textContent,
                                    timestamp,
                                    timestampSeconds,
                                    lineIndex: i
                                });
                                matched = true;
                                break;
                            }
                        }
                    }
                    
                    if (!matched && line.length > 10 && !line.startsWith('---') && (meetingInfo ? (i > (meetingInfo.date ? 1 : 0)) : true) ) { // Heuristic for non-timestamped lines
                        segments.push({
                            text: line,
                            timestamp: segments.length > 0 ? segments[segments.length-1].timestamp : '00:00', // Use previous timestamp or default
                            timestampSeconds: segments.length > 0 ? segments[segments.length-1].timestampSeconds : 0,
                            lineIndex: i
                        });
                    }
                }
                return { parsedMeeting: meetingInfo, segments };
            },
            
            processTextForKeywords(text, analysis) {
                const words = text.toLowerCase().match(/\b(\w+)\b/g) || [];
                words.forEach(word => {
                    if (word.length < 2) return;
                    analysis.wordFrequency[word] = (analysis.wordFrequency[word] || 0) + 1;
                    if (analysis.keyTerms.hasOwnProperty(word)) {
                        analysis.keyTerms[word]++;
                        this.captureTermContext(text, word, analysis);
                    }
                });
            },
            
            captureTermContext(text, term, analysis) {
                 const sentences = text.split(/(?<!\w\.\w.)(?<![A-Z][a-z]\.)(?<=\.|\?|!)\s+/); // More robust sentence split
                const regex = new RegExp(`\\b${term}\\b`, 'i'); // Create regex once for the term
                
                for (const sentence of sentences) {
                    if (regex.test(sentence)) {
                        if (analysis.termContexts[term].length < 5) {
                            const cleanSentence = sentence.trim().replace(/^\s*(and|,)\s*|\s*,\s*$/gi, '');
                            if (cleanSentence.length > 5) {
                                analysis.termContexts[term].push(cleanSentence);
                            }
                        } else {
                            break; // Stop after 5 examples
                        }
                    }
                }
            },
            
            analyzeSentiment(text) {
                let positiveScore = 0;
                let negativeScore = 0;
                const words = text.toLowerCase().match(/\b(\w+)\b/g) || [];
                const totalWords = words.length;
                if (totalWords === 0) return 'neutral';

                words.forEach((word, index) => { // Use index directly for position
                    const position = index / totalWords;
                    const positionFactor = (position < 0.3 || position > 0.7) ? 1.2 : 1.0;

                    if (AppState.wordLists.positive.includes(word)) {
                        positiveScore += 1 * positionFactor;
                    } else if (AppState.wordLists.negative.includes(word)) {
                        negativeScore += 1 * positionFactor;
                    }
                });
                
                const negationPattern = /\b(not|no|never|n't|don't|can't|isn't|aren't|wasn't|weren't)\b/g;
                if (negationPattern.test(text.toLowerCase())) {
                    if (positiveScore > negativeScore) positiveScore *= 0.8;
                    else if (negativeScore > positiveScore) negativeScore *= 0.8;
                }
                
                if (positiveScore > negativeScore * 1.2) return 'positive';
                if (negativeScore > positiveScore * 1.2) return 'negative';
                return 'neutral';
            },
            
            generateTopicClusters(analysis) {
                const topics = AppState.topicDefinitions.map(topicDef => ({
                    ...topicDef,
                    count: 0,
                    segments: []
                }));
                
                analysis.combinedSegments.forEach(segment => {
                    const lowerText = segment.text.toLowerCase();
                    topics.forEach(topic => {
                        let score = 0;
                        let keywordsFound = [];
                        topic.keywords.forEach(keyword => {
                            const regex = new RegExp(`\\b${keyword}\\b`, 'ig');
                            const matches = (lowerText.match(regex) || []).length;
                            if (matches > 0) {
                                score += matches;
                                keywordsFound.push(keyword);
                            }
                        });
                        if (score > 0) {
                            topic.count += score;
                            topic.segments.push({
                                ...segment,
                                topicRelevanceScore: score,
                                keywordsFound
                            });
                        }
                    });
                });
                return topics.sort((a, b) => b.count - a.count);
            }
        };

        // ======== UI Controller Module ========
        const UIController = {
            setLoadingState(isLoading) {
                DOM.loading.classList.toggle('hidden', !isLoading);
                DOM.results.classList.toggle('hidden', isLoading);
                DOM.analyzeBtn.disabled = isLoading;
                DOM.clearBtn.disabled = isLoading; // Disable clear during analysis too
            },
            
            showNotification(message, type = 'info') {
                const notification = document.createElement('div');
                notification.className = `fixed bottom-4 right-4 px-6 py-3 rounded-lg shadow-lg 
                                        transform opacity-0 translate-y-4 transition-all duration-300 ease-in-out z-50`;
                
                const typeClasses = {
                    success: 'bg-green-600 text-white',
                    error: 'bg-red-600 text-white',
                    warning: 'bg-yellow-500 text-white',
                    info: 'bg-primary text-white'
                };
                notification.classList.add(...(typeClasses[type] || typeClasses.info).split(' '));
                
                notification.textContent = message; // Use textContent for security
                document.body.appendChild(notification);
                
                requestAnimationFrame(() => { // Ensure element is in DOM before animating
                    notification.classList.remove('opacity-0', 'translate-y-4');
                    notification.classList.add('opacity-100', 'translate-y-0');
                });
                
                setTimeout(() => {
                    notification.classList.remove('opacity-100', 'translate-y-0');
                    notification.classList.add('opacity-0', 'translate-y-4');
                    setTimeout(() => {
                        if (document.body.contains(notification)) { // Check if still in body
                           document.body.removeChild(notification);
                        }
                    }, 300);
                }, 3000);
            },
            
            displayMeetingInfo(analysis) {
                let html = '';
                if (analysis.meetings.length > 0 && analysis.meetings[0].title !== "Transcript Analysis") { // Check if it's not the default placeholder
                    const meeting = analysis.meetings[0];
                    html = `
                        <div class="grid grid-cols-1 md:grid-cols-2 gap-4">
                            <div><p class="font-medium text-gray-700 dark:text-gray-300">Meeting Title:</p><p>${_.escape(meeting.title) || 'Unknown'}</p></div>
                            <div><p class="font-medium text-gray-700 dark:text-gray-300">Date & Time:</p><p>${_.escape(meeting.date) || 'Not specified'}</p></div>
                            <div><p class="font-medium text-gray-700 dark:text-gray-300">Meeting Type:</p><p>${_.escape(meeting.type) || 'General'}</p></div>
                            <div><p class="font-medium text-gray-700 dark:text-gray-300">Participants:</p><p>${meeting.participants?.map(_.escape).join(', ') || 'Unknown'}</p></div>
                        </div>`;
                } else {
                    html = `<p>No specific meeting information detected. Analysis performed on general transcript content.</p>`;
                }

                html += `
                    <div class="mt-4">
                        <p class="font-medium text-gray-700 dark:text-gray-300">Analysis Summary:</p>
                        <div class="grid grid-cols-1 md:grid-cols-3 gap-4 mt-2">
                            <div class="bg-gray-100 dark:bg-gray-800 p-3 rounded"><p class="text-xs uppercase text-gray-500 dark:text-gray-400">Total Segments</p><p class="text-2xl font-bold">${analysis.combinedSegments.length}</p></div>
                            <div class="bg-gray-100 dark:bg-gray-800 p-3 rounded"><p class="text-xs uppercase text-gray-500 dark:text-gray-400">Key Term Mentions</p><p class="text-2xl font-bold">${Object.values(analysis.keyTerms).reduce((a, b) => a + b, 0)}</p></div>
                            <div class="bg-gray-100 dark:bg-gray-800 p-3 rounded"><p class="text-xs uppercase text-gray-500 dark:text-gray-400">Overall Sentiment</p><p class="text-2xl font-bold ${this.getSentimentColorClass(analysis)}">${this.getOverallSentiment(analysis)}</p></div>
                        </div>
                    </div>`;
                DOM.meetingInfo.innerHTML = html;
            },
            
            getSentimentColorClass(analysis) {
                const overall = this.getOverallSentiment(analysis);
                if (overall === 'Positive') return 'text-green-600 dark:text-green-400';
                if (overall === 'Negative') return 'text-red-600 dark:text-red-400';
                return 'text-gray-600 dark:text-gray-400'; // For Mixed or Neutral
            },
            
            getOverallSentiment(analysis) {
                const { positive, negative, neutral } = analysis.sentiment;
                const total = positive + negative + neutral;
                if (total === 0) return 'Neutral';
                const posPercent = (positive / total) * 100;
                const negPercent = (negative / total) * 100;
                if (posPercent > negPercent && posPercent > (neutral / total * 100) + 10) return 'Positive'; // More nuanced check
                if (negPercent > posPercent && negPercent > (neutral / total * 100) + 10) return 'Negative';
                if (Math.abs(posPercent - negPercent) < 20) return 'Mixed'; // If positive and negative are close
                return 'Neutral'; // Default or predominantly neutral
            },
            
            renderTimelineView(analysis) {
                if (analysis.combinedSegments.length === 0) {
                    DOM.timelineContent.innerHTML = '<p>No segments found in the transcript.</p>';
                    return;
                }
                const segmentsBySource = _.groupBy(analysis.combinedSegments, 'source');
                let finalHtml = '';

                Object.entries(segmentsBySource).forEach(([source, segments]) => {
                    if (Object.keys(segmentsBySource).length > 1) {
                        finalHtml += `<div class="mb-4"><h3 class="text-lg font-medium mb-2">${_.escape(source)}</h3></div>`;
                    }
                    finalHtml += segments.map(segment => {
                        const highlightedText = this.highlightKeyTerms(_.escape(segment.text), Object.keys(analysis.keyTerms));
                        let sentimentClass = '';
                        if (segment.sentiment === 'positive') sentimentClass = 'border-l-4 border-green-500 pl-2';
                        else if (segment.sentiment === 'negative') sentimentClass = 'border-l-4 border-red-500 pl-2';
                        
                        return `
                            <div class="flex mb-4">
                                <div class="flex-none text-sm font-mono w-20 text-gray-500 dark:text-gray-400 pt-1">${_.escape(segment.timestamp)}</div>
                                <div class="flex-1 pl-4 border-l-2 border-gray-300 dark:border-gray-700">
                                    <div class="pb-2 ${sentimentClass}">${highlightedText}</div>
                                </div>
                            </div>`;
                    }).join('');
                });
                DOM.timelineContent.innerHTML = finalHtml;
            },
            
            highlightKeyTerms(text, terms) {
                let highlightedText = text;
                terms.forEach(term => {
                    const regex = new RegExp(`\\b(${_.escapeRegExp(term)})\\b`, 'gi'); // Escape term for regex
                    highlightedText = highlightedText.replace(regex, `<span class="bg-primary/20 px-1 rounded">$1</span>`);
                });
                return highlightedText;
            },
            
            renderKeywordAnalysis() {
                if (!AppState.analysis) return;
                const keyTermsData = Object.entries(AppState.analysis.keyTerms).sort((a, b) => b[1] - a[1]);
                const keywordsCtx = DOM.getCanvasContext('keywordsChart');
                if (AppState.charts.keywords) AppState.charts.keywords.destroy();
                
                const chartColors = {
                    bgColor: AppState.darkMode ? '#5D5CDE80' : '#5D5CDE',
                    borderColor: AppState.darkMode ? '#5D5CDE' : '#4A49B0',
                    textColor: AppState.darkMode ? '#e5e7eb' : '#374151'
                };
                
                AppState.charts.keywords = new Chart(keywordsCtx, {
                    type: 'bar',
                    data: {
                        labels: keyTermsData.map(item => item[0]),
                        datasets: [{
                            label: 'Mentions',
                            data: keyTermsData.map(item => item[1]),
                            backgroundColor: chartColors.bgColor,
                            borderColor: chartColors.borderColor,
                            borderWidth: 1
                        }]
                    },
                    options: { /* ... existing options ... */ 
                        responsive: true, maintainAspectRatio: false,
                        scales: { y: { beginAtZero: true, ticks: { precision: 0, color: chartColors.textColor } }, x: { ticks: { color: chartColors.textColor } } },
                        plugins: { legend: { labels: { color: chartColors.textColor } } }
                    }
                });
                
                const wordCloudEl = document.getElementById('wordCloud');
                const topWords = Object.entries(AppState.analysis.wordFrequency)
                    .filter(([word]) => word.length > 3) // Slightly longer words for word cloud
                    .sort((a, b) => b[1] - a[1])
                    .slice(0, 50); // More words for better cloud
                
                const wordCloudParts = [];
                if (topWords.length > 0) {
                    const maxCount = topWords[0][1];
                    const stopwords = ['and', 'the', 'to', 'of', 'in', 'is', 'that', 'it', 'with', 'as', 'for', 'on', 'are', 'was', 'we', 'you', 'he', 'she', 'they'];
                    topWords.forEach(([word, count]) => {
                        if (stopwords.includes(word) || count < 2) return; // Skip stopwords and very low freq
                        const fontSize = 12 + Math.floor((count / maxCount) * 28); // Adjusted scale
                        const opacity = 0.6 + (count / maxCount) * 0.4;
                        const colors = ['#5D5CDE', '#4CAF50', '#FFC107', '#F44336', '#9C27B0', '#2196F3', '#FF9800'];
                        const color = colors[Math.floor(Math.random() * colors.length)];
                        const rotation = Math.floor(Math.random() * 6) * (Math.random() < 0.5 ? -1 : 1) * 5; // More varied rotation
                        wordCloudParts.push(`<span class="inline-block m-1.5 p-1 cursor-default" style="font-size: ${fontSize}px; opacity: ${opacity}; color: ${color}; transform: rotate(${rotation}deg); line-height: 1;">${_.escape(word)}</span>`);
                    });
                }
                wordCloudEl.innerHTML = wordCloudParts.length > 0 ? wordCloudParts.join('') : '<p class="text-center text-gray-500">Not enough data for word cloud.</p>';
                
                const termContextTableBody = document.getElementById('termContextTable');
                let tableHtml = '';
                keyTermsData.forEach(([term, count]) => {
                    if (count === 0) return;
                    const contexts = AppState.analysis.termContexts[term] || [];
                    const contextHTML = contexts.length > 0 
                        ? contexts.map(ctx => {
                            const highlightedContext = _.escape(ctx).replace(new RegExp(`\\b(${_.escapeRegExp(term)})\\b`, 'gi'), '<span class="bg-primary/20 px-1 rounded">$1</span>');
                            return `<div class="mb-2 pb-2 border-b dark:border-gray-700 last:border-b-0">"${highlightedContext}"</div>`;
                        }).join('')
                        : '<em class="text-gray-500 dark:text-gray-400">No contexts captured</em>';
                    tableHtml += `<tr class="hover:bg-gray-50 dark:hover:bg-gray-800 transition-colors duration-150"><td class="px-4 py-3 whitespace-nowrap font-medium">${_.escape(term)}</td><td class="px-4 py-3 whitespace-nowrap">${count}</td><td class="px-4 py-3">${contextHTML}</td></tr>`;
                });
                termContextTableBody.innerHTML = tableHtml;
            },
            
            renderSentimentAnalysis() {
                if (!AppState.analysis) return;
                const sentimentCtx = DOM.getCanvasContext('sentimentChart');
                if (AppState.charts.sentiment) AppState.charts.sentiment.destroy();

                const chartColors = {
                    positive: '#4CAF50', negative: '#F44336', neutral: '#9E9E9E',
                    textColor: AppState.darkMode ? '#e5e7eb' : '#374151'
                };
                
                AppState.charts.sentiment = new Chart(sentimentCtx, { /* ... existing chart config ... */ 
                    type: 'doughnut',
                    data: { labels: ['Positive', 'Negative', 'Neutral'], datasets: [{ data: [ AppState.analysis.sentiment.positive, AppState.analysis.sentiment.negative, AppState.analysis.sentiment.neutral ], backgroundColor: [ chartColors.positive + (AppState.darkMode ? '90' : 'CC'), chartColors.negative + (AppState.darkMode ? '90' : 'CC'), chartColors.neutral + (AppState.darkMode ? '90' : 'CC') ], borderColor: [ chartColors.positive, chartColors.negative, chartColors.neutral ], borderWidth: 1 }] },
                    options: { responsive: true, maintainAspectRatio: false, plugins: { legend: { position: 'right', labels: { color: chartColors.textColor, padding: 20 } }, tooltip: { callbacks: { label: function(context) { const total = context.dataset.data.reduce((a,b)=>a+b,0); const value = context.parsed; const percentage = total ? Math.round((value/total)*100) : 0; return `${context.label}: ${value} (${percentage}%)`; } } } } }
                });

                const sentimentTimelineCtx = DOM.getCanvasContext('sentimentTimelineChart');
                if (AppState.charts.sentimentTimeline) AppState.charts.sentimentTimeline.destroy();
                
                const sentimentData = []; const labels = [];
                const chunkSize = Math.max(1, Math.ceil(AppState.analysis.combinedSegments.length / 15)); // More granular chunks
                
                for (let i = 0; i < AppState.analysis.combinedSegments.length; i += chunkSize) {
                    const chunk = AppState.analysis.combinedSegments.slice(i, i + chunkSize);
                    sentimentData.push({
                        positive: chunk.filter(s => s.sentiment === 'positive').length,
                        negative: chunk.filter(s => s.sentiment === 'negative').length,
                    });
                    if (chunk[0]?.timestamp && chunk[0].timestamp !== '00:00') labels.push(chunk[0].timestamp);
                    else labels.push(`Part ${Math.floor(i / chunkSize) + 1}`);
                }
                
                AppState.charts.sentimentTimeline = new Chart(sentimentTimelineCtx, { /* ... existing chart config ... */ 
                    type: 'line',
                    data: { labels: labels, datasets: [ { label: 'Positive', data: sentimentData.map(d => d.positive), borderColor: chartColors.positive, backgroundColor: chartColors.positive + '20', borderWidth: 2, tension: 0.3, fill: true }, { label: 'Negative', data: sentimentData.map(d => d.negative), borderColor: chartColors.negative, backgroundColor: chartColors.negative + '20', borderWidth: 2, tension: 0.3, fill: true } ] },
                    options: { responsive: true, maintainAspectRatio: false, scales: { y: { beginAtZero: true, ticks: { precision: 0, color: chartColors.textColor } }, x: { ticks: { color: chartColors.textColor } } }, plugins: { legend: { labels: { color: chartColors.textColor } }, tooltip: { callbacks: { title: function(context){ return `Segment: ${context[0].label}`; } } } }, interaction: { mode: 'index', intersect: false } }
                });
                
                const emotionalToneEl = document.getElementById('emotionalToneAnalysis');
                const toneCounts = {};
                Object.keys(AppState.emotionalTones).forEach(tone => { toneCounts[tone] = 0; });

                const precompiledToneRegexes = {};
                Object.entries(AppState.emotionalTones).forEach(([tone, keywords]) => {
                    if (keywords.length > 0) precompiledToneRegexes[tone] = new RegExp(`\\b(${keywords.map(_.escapeRegExp).join('|')})\\b`, 'gi');
                });

                AppState.analysis.combinedSegments.forEach(segment => {
                    const lowerText = segment.text.toLowerCase();
                    Object.entries(precompiledToneRegexes).forEach(([tone, regex]) => {
                        if (regex) {
                            const matches = lowerText.match(regex);
                            if (matches) toneCounts[tone] += matches.length;
                        }
                    });
                });
                
                const maxToneCount = Math.max(...Object.values(toneCounts), 1);
                let emotionalToneHtml = '';
                Object.entries(toneCounts).forEach(([tone, count]) => {
                    const toneColors = { Collaborative: '#4CAF50', Instructional: '#2196F3', Concerned: '#F44336', Structured: '#9C27B0' };
                    const toneColor = toneColors[tone] || '#5D5CDE';
                    const percentage = Math.min(Math.round((count / maxToneCount) * 100), 100);
                    emotionalToneHtml += `
                        <div class="bg-white dark:bg-gray-800 p-4 rounded-lg shadow-sm transition-all duration-200 hover:shadow-md">
                            <div class="flex justify-between items-center mb-2"><h4 class="font-medium">${_.escape(tone)} Tone</h4><span class="text-sm font-mono bg-gray-100 dark:bg-gray-700 px-2 py-1 rounded">${count}</span></div>
                            <div class="w-full bg-gray-200 dark:bg-gray-700 rounded-full h-2.5 mb-3"><div class="h-2.5 rounded-full" style="width: ${percentage}%; background-color: ${toneColor};"></div></div>
                            <p class="text-sm text-gray-600 dark:text-gray-400"><span class="font-medium">Keywords:</span> ${AppState.emotionalTones[tone].slice(0, 4).map(_.escape).join(', ')}${AppState.emotionalTones[tone].length > 4 ? '...' : ''}</p>
                        </div>`;
                });
                emotionalToneEl.innerHTML = emotionalToneHtml || '<p class="text-center text-gray-500">No emotional tones detected.</p>';
            },
            
            renderTopicAnalysis() {
                if (!AppState.analysis) return;
                const topicsCtx = DOM.getCanvasContext('topicsChart');
                if (AppState.charts.topics) AppState.charts.topics.destroy();

                const chartColors = { textColor: AppState.darkMode ? '#e5e7eb' : '#374151' };
                const topicColors = AppState.analysis.topicClusters.map(topic => topic.color);
                
                AppState.charts.topics = new Chart(topicsCtx, { /* ... existing chart config ... */ 
                    type: 'bar',
                    data: { labels: AppState.analysis.topicClusters.map(topic => topic.name), datasets: [{ label: 'Mentions', data: AppState.analysis.topicClusters.map(topic => topic.count), backgroundColor: topicColors.map(color => color + (AppState.darkMode ? '80' : 'CC')), borderColor: topicColors, borderWidth: 1 }] },
                    options: { responsive: true, maintainAspectRatio: false, indexAxis: 'y', scales: { y: { ticks: { color: chartColors.textColor } }, x: { beginAtZero: true, ticks: { precision: 0, color: chartColors.textColor } } }, plugins: { legend: { display: false }, tooltip: { callbacks: { label: function(context){ return `${context.parsed.x} mentions`; } } } } }
                });
                
                this.renderTopicNetwork();
                
                const topicDetailsEl = document.getElementById('topicDetails');
                let topicDetailsHtml = '';
                const maxTopicCount = Math.max(...AppState.analysis.topicClusters.map(t => t.count), 1);

                AppState.analysis.topicClusters.forEach(topic => {
                    if (topic.count === 0) return;
                    const sampleSegments = [...topic.segments].sort((a, b) => b.topicRelevanceScore - a.topicRelevanceScore).slice(0, 3);
                    const segmentsHTML = sampleSegments.map(segment => {
                        let highlightedText = _.escape(segment.text);
                        segment.keywordsFound.forEach(keyword => {
                            const regex = new RegExp(`\\b(${_.escapeRegExp(keyword)})\\b`, 'gi');
                            highlightedText = highlightedText.replace(regex, `<span style="background-color: ${topic.color}30; padding: 0 4px; border-radius: 4px;">$1</span>`);
                        });
                        return `<div class="mb-2 pb-2 border-b dark:border-gray-700 text-sm last:border-b-0"><div class="text-gray-500 dark:text-gray-400 text-xs flex justify-between"><span>${_.escape(segment.timestamp)}</span><span>Relevance: ${segment.topicRelevanceScore}</span></div>"${highlightedText}"</div>`;
                    }).join('');
                    const percentage = Math.round((topic.count / maxTopicCount) * 100);
                    topicDetailsHtml += `
                        <div class="bg-white dark:bg-gray-800 p-4 rounded-lg shadow-sm transition-all duration-200 hover:shadow-md">
                            <div style="border-left: 4px solid ${topic.color}; padding-left: 10px;">
                                <h4 class="font-medium mb-2">${_.escape(topic.name)}</h4>
                                <div class="flex items-center mb-3"><div class="w-full bg-gray-200 dark:bg-gray-700 rounded-full h-2.5"><div class="h-2.5 rounded-full" style="width: ${percentage}%; background-color: ${topic.color};"></div></div><span class="ml-2 text-sm">${topic.count} mentions</span></div>
                                <p class="text-sm mb-2 text-gray-600 dark:text-gray-400"><span class="font-medium">Keywords:</span> ${topic.keywords.map(_.escape).join(', ')}</p>
                                <div class="mt-3"><p class="text-sm font-medium mb-1">Representative mentions:</p>${segmentsHTML || '<p class="text-sm italic text-gray-500 dark:text-gray-400">No representative mentions found</p>'}</div>
                            </div>
                        </div>`;
                });
                topicDetailsEl.innerHTML = topicDetailsHtml || '<p class="text-center text-gray-500">No topics identified.</p>';
            },
            
            renderTopicNetwork() {
                const topicNetworkEl = document.getElementById('topicNetwork');
                const topics = AppState.analysis.topicClusters.filter(t => t.count > 0); // Only render topics with mentions
                if (topics.length === 0) {
                    topicNetworkEl.innerHTML = '<p class="text-center text-gray-500">No topic relationships to display.</p>';
                    return;
                }

                const svgParts = [];
                svgParts.push(`<svg viewBox="0 0 400 400" class="w-full h-full">`);
                // Central node assumed to be the primary theme or just a focal point
                const centralNodeColor = AppState.darkMode ? '#5D5CDEB0' : '#5D5CDE';
                svgParts.push(`<circle cx="200" cy="200" r="30" fill="${centralNodeColor}" /><text x="200" y="205" text-anchor="middle" fill="white" font-size="10" class="font-semibold">Focus</text>`);
                
                const totalTopics = topics.length;
                const maxCountAllTopics = Math.max(...topics.map(t => t.count || 1), 1);

                topics.forEach((topic, index) => {
                    const angle = (2 * Math.PI * index) / totalTopics;
                    const radius = 120; // Increased radius for better spacing
                    const x = 200 + radius * Math.cos(angle);
                    const y = 200 + radius * Math.sin(angle);
                    const minSize = 15; const maxSize = 30; // Adjusted node sizes
                    const size = minSize + ((topic.count / maxCountAllTopics) * (maxSize - minSize));
                    
                    svgParts.push(`<circle cx="${x}" cy="${y}" r="${size}" fill="${topic.color}${AppState.darkMode ? 'B0' : ''}" />`);
                    svgParts.push(`<text x="${x}" y="${y + 4}" text-anchor="middle" fill="${AppState.darkMode ? '#FFF' : '#000'}" font-size="9" class="font-medium">${_.escape(topic.name.split(' ')[0])}</text>`);
                    svgParts.push(`<line x1="200" y1="200" x2="${x}" y2="${y}" stroke-width="${Math.max(1, 2 + (topic.count / maxCountAllTopics) * 3)}" stroke="${topic.color}80" />`);
                    
                    // Connections between related topics (simplified: not shown to avoid clutter, or implement co-occurrence)
                });
                
                svgParts.push('</svg>');
                topicNetworkEl.innerHTML = svgParts.join('');
            },
            
            countSharedMentions(topic1, topic2) { // Unused in current simplified network, but kept for potential future use
                const topic1Segments = new Set(topic1.segments.map(s => s.lineIndex));
                const topic2Segments = new Set(topic2.segments.map(s => s.lineIndex));
                let count = 0;
                topic1Segments.forEach(segmentId => { if (topic2Segments.has(segmentId)) count++; });
                return count;
            }
        };

        // ======== Data Export Module ========
        const DataExporter = {
            downloadAnalysisJSON(analysis) {
                const exportData = {
                    meetings: analysis.meetings,
                    analysis: {
                        keyTerms: analysis.keyTerms,
                        sentiment: analysis.sentiment,
                        topicClusters: analysis.topicClusters.map(topic => ({ name: topic.name, keywords: topic.keywords, count: topic.count }))
                    },
                    segments: analysis.combinedSegments.map(segment => ({ source: segment.source, text: segment.text, timestamp: segment.timestamp, sentiment: segment.sentiment }))
                };
                const dataStr = "data:text/json;charset=utf-8," + encodeURIComponent(JSON.stringify(exportData, null, 2));
                const downloadAnchorNode = document.createElement('a');
                downloadAnchorNode.setAttribute("href", dataStr);
                downloadAnchorNode.setAttribute("download", "transcript_analysis.json");
                document.body.appendChild(downloadAnchorNode);
                downloadAnchorNode.click();
                downloadAnchorNode.remove();
            },
            
            generateTextReport(analysis) {
                let report = `MEETING TRANSCRIPT ANALYSIS\n=============================================\n\n`;
                if (analysis.meetings.length > 0 && analysis.meetings[0].title !== "Transcript Analysis") {
                    const meeting = analysis.meetings[0];
                    report += `Meeting: ${meeting.title || 'Unknown'}\nDate: ${meeting.date || 'Not specified'}\nType: ${meeting.type || 'General'}\n`;
                    if (meeting.participants && meeting.participants.length) report += `Participants: ${meeting.participants.join(', ')}\n`;
                    report += `\n`;
                }
                report += `SUMMARY STATISTICS\n---------------------------------------------\n`;
                report += `Total Segments Analyzed: ${analysis.combinedSegments.length}\nKey Term Mentions: ${Object.values(analysis.keyTerms).reduce((a, b) => a + b, 0)}\n`;
                report += `Overall Sentiment: ${UIController.getOverallSentiment(analysis)}\n  - Positive Segments: ${analysis.sentiment.positive}\n  - Negative Segments: ${analysis.sentiment.negative}\n  - Neutral Segments: ${analysis.sentiment.neutral}\n\n`;
                report += `KEY TERMS\n---------------------------------------------\n`;
                Object.entries(analysis.keyTerms).sort((a, b) => b[1] - a[1]).forEach(([term, count]) => { if (count > 0) report += `${term}: ${count} mentions\n`; });
                report += `\nMAIN TOPICS\n---------------------------------------------\n`;
                analysis.topicClusters.filter(topic => topic.count > 0).forEach(topic => { report += `${topic.name}: ${topic.count} mentions\nKeywords: ${topic.keywords.join(', ')}\n\n`; });
                return report;
            }
        };

        // Initialize the application
        document.addEventListener('DOMContentLoaded', () => {
            EventHandlers.init();
        });
    </script>
</body>
</html>