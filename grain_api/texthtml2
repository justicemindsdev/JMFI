<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Meeting Transcript Analyzer</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/lodash.js/4.17.21/lodash.min.js"></script>
    <script>
        tailwind.config = {
            theme: {
                extend: {
                    colors: {
                        primary: '#5D5CDE',
                        secondary: '#4CAF50',
                        warning: '#FFC107',
                        danger: '#F44336',
                        accent: '#9C27B0'
                    }
                }
            },
            darkMode: 'class',
        }
    </script>
</head>
<body class="bg-white dark:bg-gray-900 text-gray-900 dark:text-gray-100 transition-colors duration-200">
    <div class="container mx-auto p-4 max-w-6xl">
        <header class="mb-8">
            <h1 class="text-3xl font-bold text-primary mb-2">Meeting Transcript Analyzer</h1>
            <p class="text-gray-600 dark:text-gray-400">Advanced analysis and visualization of meeting transcripts</p>
        </header>
        
        <section id="input-section" class="mb-8">
            <h2 class="text-xl font-semibold mb-4">Input Meeting Transcript</h2>
            <div class="flex flex-col space-y-4">
                <textarea id="textInput" placeholder="Paste your meeting transcript here..." class="w-full p-3 border rounded-lg text-base dark:bg-gray-800 dark:border-gray-700 h-60 focus:border-primary focus:ring-1 focus:ring-primary transition-all duration-200"></textarea>
                
                <div class="flex flex-col sm:flex-row items-start sm:items-center gap-4">
                    <div class="relative">
                        <input type="file" id="fileInput" accept=".txt" class="absolute inset-0 opacity-0 w-full cursor-pointer" multiple>
                        <button class="bg-primary hover:bg-primary/90 text-white font-medium py-2 px-4 rounded transition-colors duration-200">
                            Upload Transcript Files
                        </button>
                    </div>
                    <span id="fileNames" class="text-sm text-gray-600 dark:text-gray-400"></span>
                </div>
            </div>
        </section>
        
        <section id="action-section" class="flex flex-wrap gap-4 mb-8">
            <button id="analyzeBtn" class="bg-primary hover:bg-primary/90 text-white font-medium py-2 px-6 rounded transition-colors duration-200">
                Analyze Transcript
            </button>
            
            <button id="clearBtn" class="bg-gray-200 hover:bg-gray-300 dark:bg-gray-700 dark:hover:bg-gray-600 text-gray-800 dark:text-gray-200 font-medium py-2 px-6 rounded transition-colors duration-200">
                Clear All
            </button>
            
            <button id="themeToggleBtn" class="ml-auto bg-gray-200 hover:bg-gray-300 dark:bg-gray-700 dark:hover:bg-gray-600 text-gray-800 dark:text-gray-200 font-medium py-2 px-4 rounded flex items-center transition-colors duration-200">
                <span id="themeIcon">ðŸŒ™</span>
                <span class="ml-2" id="themeText">Dark Mode</span>
            </button>
        </section>

        <div id="loading" class="hidden">
            <div class="flex items-center justify-center p-6">
                <div class="animate-spin rounded-full h-12 w-12 border-t-2 border-b-2 border-primary"></div>
                <span class="ml-3 text-lg">Analyzing transcript...</span>
            </div>
        </div>
        
        <section id="results" class="hidden space-y-8">
            <!-- Meeting Metadata -->
            <div class="border dark:border-gray-700 rounded-lg overflow-hidden shadow-sm">
                <div class="bg-gray-100 dark:bg-gray-800 px-4 py-3 font-semibold border-b dark:border-gray-700">Meeting Information</div>
                <div id="meetingInfo" class="p-4"></div>
            </div>

            <!-- Tabs for different analysis views -->
            <div class="border dark:border-gray-700 rounded-lg overflow-hidden shadow-sm">
                <div class="border-b dark:border-gray-700">
                    <nav class="flex flex-wrap">
                        <button data-tab="Timeline" class="tab-button px-4 py-3 text-sm font-medium border-b-2 border-primary">Timeline View</button>
                        <button data-tab="Keywords" class="tab-button px-4 py-3 text-sm font-medium border-b-2 border-transparent">Keyword Analysis</button>
                        <button data-tab="Sentiment" class="tab-button px-4 py-3 text-sm font-medium border-b-2 border-transparent">Sentiment Analysis</button>
                        <button data-tab="Topics" class="tab-button px-4 py-3 text-sm font-medium border-b-2 border-transparent">Topic Clusters</button>
                    </nav>
                </div>
                
                <!-- Timeline View Tab Content -->
                <div id="contentTimeline" class="tab-content p-4">
                    <div id="timelineContent" class="space-y-4"></div>
                </div>
                
                <!-- Keyword Analysis Tab Content -->
                <div id="contentKeywords" class="tab-content p-4 hidden">
                    <div class="grid grid-cols-1 md:grid-cols-2 gap-6">
                        <div>
                            <h3 class="text-lg font-medium mb-3">Key Terms Frequency</h3>
                            <div class="h-80">
                                <canvas id="keywordsChart"></canvas>
                            </div>
                        </div>
                        <div>
                            <h3 class="text-lg font-medium mb-3">Word Cloud</h3>
                            <div id="wordCloudContainer" class="h-80 border rounded-lg p-4 flex items-center justify-center">
                                <div id="wordCloud" class="w-full h-full overflow-auto"></div>
                            </div>
                        </div>
                    </div>
                    <div class="mt-6">
                        <h3 class="text-lg font-medium mb-3">Term Context</h3>
                        <div class="overflow-auto max-h-80">
                            <table class="min-w-full divide-y divide-gray-200 dark:divide-gray-700">
                                <thead class="bg-gray-50 dark:bg-gray-800">
                                    <tr>
                                        <th class="px-4 py-2 text-left text-xs font-medium text-gray-500 dark:text-gray-400 uppercase tracking-wider">Term</th>
                                        <th class="px-4 py-2 text-left text-xs font-medium text-gray-500 dark:text-gray-400 uppercase tracking-wider">Frequency</th>
                                        <th class="px-4 py-2 text-left text-xs font-medium text-gray-500 dark:text-gray-400 uppercase tracking-wider">Context Examples</th>
                                    </tr>
                                </thead>
                                <tbody id="termContextTable" class="bg-white dark:bg-gray-900 divide-y divide-gray-200 dark:divide-gray-700"></tbody>
                            </table>
                        </div>
                    </div>
                </div>
                
                <!-- Sentiment Analysis Tab Content -->
                <div id="contentSentiment" class="tab-content p-4 hidden">
                    <div class="grid grid-cols-1 md:grid-cols-2 gap-6">
                        <div>
                            <h3 class="text-lg font-medium mb-3">Overall Sentiment</h3>
                            <div class="h-80">
                                <canvas id="sentimentChart"></canvas>
                            </div>
                        </div>
                        <div>
                            <h3 class="text-lg font-medium mb-3">Sentiment Timeline</h3>
                            <div class="h-80">
                                <canvas id="sentimentTimelineChart"></canvas>
                            </div>
                        </div>
                    </div>
                    <div class="mt-6">
                        <h3 class="text-lg font-medium mb-3">Emotional Tone Analysis</h3>
                        <div id="emotionalToneAnalysis" class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4"></div>
                    </div>
                </div>
                
                <!-- Topic Clusters Tab Content -->
                <div id="contentTopics" class="tab-content p-4 hidden">
                    <div class="grid grid-cols-1 lg:grid-cols-2 gap-6">
                        <div>
                            <h3 class="text-lg font-medium mb-3">Main Discussion Topics</h3>
                            <div class="h-80">
                                <canvas id="topicsChart"></canvas>
                            </div>
                        </div>
                        <div>
                            <h3 class="text-lg font-medium mb-3">Topic Relationships</h3>
                            <div id="topicRelationships" class="h-80 border rounded-lg p-4 flex items-center justify-center bg-white dark:bg-gray-800">
                                <div id="topicNetwork" class="w-full h-full"></div>
                            </div>
                        </div>
                    </div>
                    <div class="mt-6">
                        <h3 class="text-lg font-medium mb-3">Topic Details</h3>
                        <div id="topicDetails" class="space-y-4"></div>
                    </div>
                </div>
            </div>

            <div class="flex justify-end gap-4">
                <button id="downloadBtn" class="bg-primary hover:bg-primary/90 text-white font-medium py-2 px-4 rounded transition-colors duration-200">
                    Download Analysis
                </button>
                <button id="copyReportBtn" class="bg-gray-200 hover:bg-gray-300 dark:bg-gray-700 dark:hover:bg-gray-600 text-gray-800 dark:text-gray-200 font-medium py-2 px-4 rounded transition-colors duration-200">
                    Copy Summary Report
                </button>
            </div>
        </section>
    </div>

    <script>
        /**
         * Transcript Analyzer - Core Application
         * Advanced meeting transcript analysis system with enhanced performance and UX
         */
        
        // ======== Application State Management ========
        const AppState = {
            transcripts: [],
            analysis: null,
            charts: {},
            darkMode: false,

            // Defined key terms for analysis
            keyTerms: {
                professional: 0,
                professionals: 0,
                parent: 0,
                parents: 0,
                partner: 0,
                partners: 0,
                partnership: 0,
                practice: 0
            },
            
            // Sentiment analysis word lists
            wordLists: {
                positive: ["good", "great", "excellent", "happy", "positive", "love", "best", "amazing", 
                          "wonderful", "success", "beautiful", "joy", "partnership", "partners", 
                          "together", "streamlined", "able", "effective", "efficient", "innovative"],
                
                negative: ["bad", "terrible", "worst", "hate", "negative", "poor", "awful", "horrible", 
                          "failure", "sad", "wrong", "disaster", "fair", "armed", "emotionally", 
                          "unstable", "difficult", "problem", "issue", "concern"]
            },
            
            // Topic definitions
            topicDefinitions: [
                {
                    name: "Professional-Parent Relationship",
                    keywords: ["professional", "professionals", "parent", "parents", "relationship"],
                    color: "#4CAF50"
                },
                {
                    name: "Partnership Model",
                    keywords: ["partner", "partners", "partnership", "together", "pilot"],
                    color: "#FFC107"
                },
                {
                    name: "Practice & Training",
                    keywords: ["practice", "training", "trained", "language", "speak", "teach"],
                    color: "#9C27B0"
                },
                {
                    name: "Challenges & Issues",
                    keywords: ["fair", "dealing", "armed", "emotionally", "unstable"],
                    color: "#F44336"
                }
            ],
            
            // Emotional tone definitions
            emotionalTones: {
                'Collaborative': ['partnership', 'partners', 'together', 'working', 'cooperation', 'joint'],
                'Instructional': ['teach', 'language', 'learn', 'training', 'demonstrate', 'explain'],
                'Concerned': ['fair', 'dealing', 'armed', 'emotionally', 'unstable', 'worried'],
                'Structured': ['practice', 'pilot', 'program', 'system', 'process', 'framework']
            },
            
            reset() {
                this.transcripts = [];
                this.analysis = null;
                // Destroy existing charts
                Object.values(this.charts).forEach(chart => {
                    if (chart && typeof chart.destroy === 'function') {
                        chart.destroy();
                    }
                });
                this.charts = {};
                
                // Reset key terms
                Object.keys(this.keyTerms).forEach(key => {
                    this.keyTerms[key] = 0;
                });
            }
        };

        // ======== DOM Elements ========
        const DOM = {
            textInput: document.getElementById('textInput'),
            fileInput: document.getElementById('fileInput'),
            fileNames: document.getElementById('fileNames'),
            analyzeBtn: document.getElementById('analyzeBtn'),
            clearBtn: document.getElementById('clearBtn'),
            themeToggleBtn: document.getElementById('themeToggleBtn'),
            themeIcon: document.getElementById('themeIcon'),
            themeText: document.getElementById('themeText'),
            loading: document.getElementById('loading'),
            results: document.getElementById('results'),
            meetingInfo: document.getElementById('meetingInfo'),
            timelineContent: document.getElementById('timelineContent'),
            termContextTable: document.getElementById('termContextTable'),
            downloadBtn: document.getElementById('downloadBtn'),
            copyReportBtn: document.getElementById('copyReportBtn'),
            
            // Tab elements
            tabButtons: document.querySelectorAll('.tab-button'),
            tabContents: document.querySelectorAll('.tab-content'),
            
            // Canvas contexts (loaded on demand)
            canvasContexts: {},
            
            // Method to get canvas context
            getCanvasContext(id) {
                if (!this.canvasContexts[id]) {
                    const canvas = document.getElementById(id);
                    if (canvas) {
                        this.canvasContexts[id] = canvas.getContext('2d');
                    }
                }
                return this.canvasContexts[id];
            }
        };

        // ======== Event Handlers ========
        const EventHandlers = {
            init() {
                // Initialize event listeners
                DOM.fileInput.addEventListener('change', this.handleFileUpload);
                DOM.analyzeBtn.addEventListener('click', this.analyzeTranscript);
                DOM.clearBtn.addEventListener('click', this.clearAll);
                DOM.downloadBtn.addEventListener('click', this.downloadAnalysis);
                DOM.copyReportBtn.addEventListener('click', this.copyReport);
                DOM.themeToggleBtn.addEventListener('click', this.toggleTheme);
                
                // Tab event listeners
                DOM.tabButtons.forEach(button => {
                    button.addEventListener('click', () => {
                        const tabName = button.getAttribute('data-tab');
                        this.switchTab(tabName); // 'this' here correctly refers to EventHandlers
                    });
                });
                
                // Initialize theme based on system preference
                this.initTheme();
            },
            
            async handleFileUpload(event) {
                const files = event.target.files;
                if (!files.length) return;
                
                const fileNamesList = [];
                AppState.transcripts = []; // Reset transcripts when new files are uploaded
                
                for (const file of files) {
                    fileNamesList.push(file.name);
                    
                    try {
                        const text = await FileProcessor.readFileContent(file);
                        AppState.transcripts.push({
                            source: file.name,
                            content: text
                        });
                    } catch (error) {
                        console.error('Error reading file:', error);
                        UIController.showNotification('Error reading file: ' + file.name, 'error');
                    }
                }
                
                DOM.fileNames.textContent = fileNamesList.join(', ');
                
                if (!DOM.textInput.value && AppState.transcripts.length > 0) {
                    DOM.textInput.value = AppState.transcripts[0].content;
                }
            },
            
            async analyzeTranscript() {
                const inputText = DOM.textInput.value.trim();
                
                // Consolidate transcript source determination
                let transcriptsToAnalyze = [...AppState.transcripts]; // Start with copies of file transcripts

                if (inputText) {
                    if (transcriptsToAnalyze.length === 0) {
                        // Only text input is present
                        transcriptsToAnalyze.push({ source: 'Manual Input', content: inputText });
                    } else {
                        // Files are present, check if manual input is different
                        const manualInputExists = transcriptsToAnalyze.some(t => t.source === 'Manual Input' && t.content === inputText);
                        if (!manualInputExists) {
                            // Potentially add as a separate transcript or decide on a strategy (e.g., prioritize one)
                            // For now, let's assume if files are loaded, manual input is ignored unless it's the *only* thing.
                            // This part of logic could be refined based on exact desired behavior when both exist.
                            // The original logic mostly handled the "manual input only" or "files only" cases.
                            // If files are loaded, `AppState.transcripts` is populated.
                            // If `inputText` is also there, it could be an override or an addition.
                            // Let's keep it simple: if files loaded, they are primary. If textarea has distinct content, it's an additional source.
                            // However, the provided screenshot context seems to imply that the text area content *is* the content to be analyzed.
                            // Let's assume for this fix: if text area has content, it's the primary source for this analysis run,
                            // overriding any previously file-loaded transcripts *for this specific analysis click*.
                            // This keeps AppState.transcripts from file uploads intact for subsequent analyses if desired.
                            transcriptsToAnalyze = [{ source: 'Manual Input', content: inputText }];
                        }
                    }
                }
                
                if (transcriptsToAnalyze.length === 0) {
                    UIController.showNotification('Please enter a transcript or upload a file to analyze', 'warning');
                    return;
                }
                
                UIController.setLoadingState(true);
                
                requestAnimationFrame(async () => {
                    try {
                        AppState.analysis = await TranscriptAnalyzer.analyzeTranscripts(transcriptsToAnalyze);
                        
                        UIController.displayMeetingInfo(AppState.analysis);
                        UIController.renderTimelineView(AppState.analysis);
                        
                        // Ensure the timeline tab is active
                        EventHandlers.switchTab('Timeline'); // CORRECTED: Call on EventHandlers
                        
                        UIController.setLoadingState(false);
                    } catch (error) {
                        console.error('Error analyzing transcript:', error);
                        UIController.setLoadingState(false);
                        UIController.showNotification('Error analyzing transcript: ' + error.message, 'error');
                    }
                });
            },
            
            switchTab(tabName) {
                // Update tab buttons
                DOM.tabButtons.forEach(button => {
                    const isActive = button.getAttribute('data-tab') === tabName;
                    button.classList.toggle('border-primary', isActive);
                    button.classList.toggle('text-primary', isActive); 
                    button.classList.toggle('border-transparent', !isActive);
                    button.classList.toggle('text-gray-600', !isActive && !AppState.darkMode);
                    button.classList.toggle('dark:text-gray-400', !isActive && AppState.darkMode);
                });
                
                // Update tab contents
                DOM.tabContents.forEach(content => {
                    const contentId = `content${tabName}`;
                    content.classList.toggle('hidden', content.id !== contentId);
                });
                
                if (AppState.analysis) {
                    switch (tabName) {
                        case 'Keywords':
                            UIController.renderKeywordAnalysis();
                            break;
                        case 'Sentiment':
                            UIController.renderSentimentAnalysis();
                            break;
                        case 'Topics':
                            UIController.renderTopicAnalysis();
                            break;
                    }
                }
            },
            
            clearAll() {
                DOM.textInput.value = '';
                DOM.fileInput.value = ''; 
                DOM.fileNames.textContent = '';
                AppState.reset();
                DOM.results.classList.add('hidden');
                
                DOM.timelineContent.innerHTML = '';
                if (AppState.charts.keywords) AppState.charts.keywords.destroy();
                if (AppState.charts.sentiment) AppState.charts.sentiment.destroy();
                if (AppState.charts.sentimentTimeline) AppState.charts.sentimentTimeline.destroy();
                if (AppState.charts.topics) AppState.charts.topics.destroy();
                AppState.charts = {}; // Clear the chart references

                document.getElementById('wordCloud').innerHTML = '';
                document.getElementById('termContextTable').innerHTML = '';
                document.getElementById('emotionalToneAnalysis').innerHTML = '';
                document.getElementById('topicNetwork').innerHTML = '';
                document.getElementById('topicDetails').innerHTML = '';
                DOM.meetingInfo.innerHTML = '';


                UIController.showNotification('All data cleared', 'info');
            },
            
            downloadAnalysis() {
                if (!AppState.analysis) return;
                DataExporter.downloadAnalysisJSON(AppState.analysis);
                UIController.showNotification('Analysis downloaded', 'success');
            },
            
            copyReport() {
                if (!AppState.analysis) return;
                const report = DataExporter.generateTextReport(AppState.analysis);
                navigator.clipboard.writeText(report)
                    .then(() => UIController.showNotification('Report copied to clipboard', 'success'))
                    .catch(err => UIController.showNotification('Failed to copy: ' + err, 'error'));
            },
            
            initTheme() {
                const storedTheme = localStorage.getItem('theme');
                if (storedTheme === 'dark') {
                    this.setDarkMode(true);
                } else if (storedTheme === 'light') {
                    this.setDarkMode(false);
                } else {
                    const prefersDark = window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches;
                    this.setDarkMode(prefersDark);
                }
                
                window.matchMedia('(prefers-color-scheme: dark)').addEventListener('change', event => {
                    if (!localStorage.getItem('theme')) { 
                       this.setDarkMode(event.matches);
                    }
                });
            },
            
            toggleTheme() {
                this.setDarkMode(!AppState.darkMode);
            },
            
            setDarkMode(isDark) {
                AppState.darkMode = isDark;
                localStorage.setItem('theme', isDark ? 'dark' : 'light');
                document.documentElement.classList.toggle('dark', isDark);
                DOM.themeIcon.textContent = isDark ? 'â˜€ï¸' : 'ðŸŒ™';
                DOM.themeText.textContent = isDark ? 'Light Mode' : 'Dark Mode';
                
                if (AppState.analysis && !DOM.results.classList.contains('hidden')) {
                    const activeTabButton = Array.from(DOM.tabButtons).find(button => button.classList.contains('border-primary'));
                    if (activeTabButton) {
                        const activeTabName = activeTabButton.getAttribute('data-tab');
                        if (activeTabName === 'Keywords') UIController.renderKeywordAnalysis();
                        if (activeTabName === 'Sentiment') UIController.renderSentimentAnalysis();
                        if (activeTabName === 'Topics') UIController.renderTopicAnalysis();
                    }
                }
            }
        };

        // ======== File Processing Module ========
        const FileProcessor = {
            async readFileContent(file) {
                return new Promise((resolve, reject) => {
                    const reader = new FileReader();
                    reader.onload = event => resolve(event.target.result);
                    reader.onerror = error => reject(error);
                    reader.readAsText(file);
                });
            }
        };

        // ======== Transcript Analysis Module ========
        const TranscriptAnalyzer = {
            async analyzeTranscripts(transcripts) {
                const analysis = {
                    meetings: [],
                    combinedSegments: [],
                    keyTerms: { ...AppState.keyTerms }, 
                    termContexts: {},
                    wordFrequency: {},
                    sentiment: { positive: 0, negative: 0, neutral: 0 },
                    topicClusters: []
                };
                
                Object.keys(analysis.keyTerms).forEach(term => {
                    analysis.keyTerms[term] = 0;
                    analysis.termContexts[term] = []; 
                });
                
                const processedResults = await Promise.all(
                    transcripts.map(transcript => this.processTranscript(transcript, analysis))
                );
                
                processedResults.forEach(result => {
                    if (result.parsedMeeting) {
                        analysis.meetings.push(result.parsedMeeting);
                    }
                    analysis.combinedSegments.push(...result.segments);
                });

                if (analysis.meetings.length === 0 && analysis.combinedSegments.length > 0) {
                     analysis.meetings.push({ title: "General Transcript", type: "General", participants: [], date: "N/A" });
                }
                
                analysis.combinedSegments.sort((a, b) => {
                    if (a.timestampSeconds !== null && b.timestampSeconds !== null) {
                        return a.timestampSeconds - b.timestampSeconds;
                    }
                    return 0; 
                });
                
                analysis.topicClusters = this.generateTopicClusters(analysis);
                return analysis;
            },
            
            async processTranscript(transcript, analysis) { 
                const { parsedMeeting, segments } = this.parseTranscript(transcript.content);
                
                segments.forEach(segment => {
                    segment.source = transcript.source;
                    if (parsedMeeting) segment.meetingTitle = parsedMeeting.title;
                    this.processTextForKeywords(segment.text, analysis); 
                    segment.sentiment = this.analyzeSentiment(segment.text);
                    analysis.sentiment[segment.sentiment]++; 
                });
                return { parsedMeeting, segments };
            },
            
            parseTranscript(text) {
                const lines = text.split('\n').filter(line => line.trim() !== '');
                let meetingInfo = null;
                const segments = [];
                
                if (lines.length > 0) {
                    const titleRegex = /(.*) Meeting with (.*)/i;
                    const dateRegex = /([A-Za-z]+\s+\d{1,2},\s+\d{4})\s+(\d{1,2}:\d{2}\s*[AP]M)\s*(?:-\s*(.*))?/i;

                    let lineOffset = 0;
                    const firstLineTitleMatch = lines[0].match(titleRegex);
                    if (firstLineTitleMatch) {
                        meetingInfo = {
                            title: firstLineTitleMatch[0].trim(),
                            type: firstLineTitleMatch[1]?.trim() || 'General',
                            participants: firstLineTitleMatch[2]?.split(',').map(p => p.trim()) || []
                        };
                        lineOffset = 1;
                        if (lines.length > 1) {
                            const secondLineDateMatch = lines[1].match(dateRegex);
                            if (secondLineDateMatch) {
                                meetingInfo.date = lines[1].trim(); // Store full matched date string
                                lineOffset = 2;
                            }
                        }
                    }
                }
                 if (!meetingInfo && lines.length > 0) { // Default if no specific metadata found
                    meetingInfo = { title: "Transcript Analysis", type: "General", participants: [], date: "N/A" };
                }


                const timestampPatterns = [
                    // Format: [DD/MM/YYYY, HH:MM:SS] Speaker: Text
                    /^\[(\d{2}\/\d{2}\/\d{4}),?\s*(\d{2}:\d{2}:\d{2})\]\s*(?:(.+?):\s*)?(.+)$/i,
                     // Format: (HH:MM:SS) Speaker: Text
                    /^\((\d{1,2}:\d{2}(:\d{2})?)\)\s*(?:(.+?):\s*)?(.+)$/i,
                    // Format: HH:MM:SS Speaker: Text
                    /^(\d{1,2}:\d{2}(:\d{2})?)\s*(?:(.+?):\s*)?(.+)$/i,
                    // Format: ... Speaker text HH:MM / HH:MM:SS
                    /^\.\.\.\s*(?:(.+?)\s+)?(.+?)\s+(\d{1,2}:\d{2}(:\d{2})?)$/i,
                    // Format: [HH:MM:SS] Speaker: text OR [HH:MM] Speaker: text
                    /^\[(\d{1,2}:\d{2}(:\d{2})?)\]\s*(?:(.+?):\s*)?(.+)$/i,
                    // Format: Speaker (HH:MM:SS): text OR Speaker (HH:MM): text
                    /^(?:(.+?)\s+)?\((\d{1,2}:\d{2}(:\d{2})?)\):\s*(.+)$/i,
                ];

                let lineOffsetForSegments = 0;
                if (meetingInfo && meetingInfo.title !== "Transcript Analysis") { // Adjust if metadata was parsed
                    if (meetingInfo.title && lines[0] === meetingInfo.title) lineOffsetForSegments++;
                    if (meetingInfo.date && lines[lineOffsetForSegments] === meetingInfo.date) lineOffsetForSegments++;
                }


                for (let i = lineOffsetForSegments; i < lines.length; i++) {
                    const line = lines[i].trim();
                    if (!line) continue;

                    let matched = false;
                    for (const pattern of timestampPatterns) {
                        const match = line.match(pattern);
                        if (match) {
                            let timestampStr, speaker, textContent;
                            let dateStr = null; // For formats that include date

                            if (pattern === timestampPatterns[0]) { // [DD/MM/YYYY, HH:MM:SS] Speaker: Text
                                dateStr = match[1]; // Not used for sorting directly, but for context
                                timestampStr = match[2];
                                speaker = match[3]?.trim();
                                textContent = match[4].trim();
                            } else if (pattern === timestampPatterns[1] || pattern === timestampPatterns[4] || pattern === timestampPatterns[5]) { // (HH:MM:SS) Speaker: Text OR [HH:MM:SS] Speaker: text etc.
                                timestampStr = match[1] || match[2]; // some patterns have timestamp in 1 or 2
                                speaker = match[3]?.trim() || (pattern === timestampPatterns[5] ? match[1]?.trim() : null);
                                textContent = match[4].trim();
                            } else if (pattern === timestampPatterns[2]) { // HH:MM:SS Speaker: Text
                                timestampStr = match[1];
                                speaker = match[3]?.trim();
                                textContent = match[4].trim();
                            } else if (pattern === timestampPatterns[3]) { // ... Speaker text HH:MM
                                speaker = match[1]?.trim(); // This could be the speaker or part of the text
                                textContent = match[2].trim();
                                timestampStr = match[3].trim();
                                if (speaker && textContent.toLowerCase().startsWith(speaker.toLowerCase())) { // Check if speaker is part of text
                                     textContent = textContent.substring(speaker.length).trim().replace(/^[:\s]+/, '');
                                } else if (speaker) {
                                     textContent = speaker + " " + textContent; // Speaker was actually part of message
                                     speaker = null;
                                }
                            }
                            
                            if (speaker) textContent = `${speaker}: ${textContent}`;

                            const timestampParts = timestampStr.split(':');
                            let timestampSeconds = null;
                            if (timestampParts.length === 2) {
                                timestampSeconds = parseInt(timestampParts[0]) * 60 + parseInt(timestampParts[1]);
                            } else if (timestampParts.length === 3) {
                                timestampSeconds = parseInt(timestampParts[0]) * 3600 + parseInt(timestampParts[1]) * 60 + parseInt(timestampParts[2]);
                            }
                            
                            if (textContent && timestampStr) {
                                segments.push({ text: textContent, timestamp: timestampStr, timestampSeconds, lineIndex: i });
                                matched = true;
                                break;
                            }
                        }
                    }
                    
                    if (!matched && line.length > 10 && !line.startsWith('---')) { 
                        segments.push({ text: line, timestamp: segments.length > 0 ? segments[segments.length-1].timestamp : '00:00', timestampSeconds: segments.length > 0 ? segments[segments.length-1].timestampSeconds : 0, lineIndex: i });
                    }
                }
                return { parsedMeeting: meetingInfo, segments };
            },
            
            processTextForKeywords(text, analysis) {
                const words = text.toLowerCase().match(/\b(\w{2,})\b/g) || []; // Min 2 char words
                words.forEach(word => {
                    analysis.wordFrequency[word] = (analysis.wordFrequency[word] || 0) + 1;
                    if (analysis.keyTerms.hasOwnProperty(word)) {
                        analysis.keyTerms[word]++;
                        this.captureTermContext(text, word, analysis);
                    }
                });
            },
            
            captureTermContext(text, term, analysis) {
                 const sentences = text.split(/(?<!\w\.\w.)(?<![A-Z][a-z]\.)(?<=\.|\?|!)\s+/); 
                const regex = new RegExp(`\\b${_.escapeRegExp(term)}\\b`, 'i'); 
                
                for (const sentence of sentences) {
                    if (regex.test(sentence)) {
                        if (analysis.termContexts[term].length < 5) {
                            const cleanSentence = sentence.trim().replace(/^\s*(and|,)\s*|\s*,\s*$/gi, '');
                            if (cleanSentence.length > 5) {
                                analysis.termContexts[term].push(cleanSentence);
                            }
                        } else {
                            break; 
                        }
                    }
                }
            },
            
            analyzeSentiment(text) {
                let positiveScore = 0; let negativeScore = 0;
                const words = text.toLowerCase().match(/\b(\w+)\b/g) || [];
                const totalWords = words.length;
                if (totalWords === 0) return 'neutral';

                words.forEach((word, index) => { 
                    const position = index / totalWords;
                    const positionFactor = (position < 0.3 || position > 0.7) ? 1.2 : 1.0;
                    if (AppState.wordLists.positive.includes(word)) positiveScore += 1 * positionFactor;
                    else if (AppState.wordLists.negative.includes(word)) negativeScore += 1 * positionFactor;
                });
                
                if (/\b(not|no|never|n't|don't|can't|isn't|aren't|wasn't|weren't)\b/gi.test(text.toLowerCase())) {
                    if (positiveScore > negativeScore) positiveScore *= 0.8;
                    else if (negativeScore > positiveScore) negativeScore *= 0.8;
                }
                
                if (positiveScore > negativeScore * 1.2) return 'positive';
                if (negativeScore > positiveScore * 1.2) return 'negative';
                return 'neutral';
            },
            
            generateTopicClusters(analysis) {
                const topics = AppState.topicDefinitions.map(topicDef => ({ ...topicDef, count: 0, segments: [] }));
                const precompiledTopicRegexes = {};
                topics.forEach(topic => {
                     if (topic.keywords.length > 0) {
                        precompiledTopicRegexes[topic.name] = new RegExp(`\\b(${topic.keywords.map(_.escapeRegExp).join('|')})\\b`, 'gi');
                    }
                });

                analysis.combinedSegments.forEach(segment => {
                    const lowerText = segment.text.toLowerCase();
                    topics.forEach(topic => {
                        const regex = precompiledTopicRegexes[topic.name];
                        if (!regex) return;

                        let score = 0;
                        let keywordsFound = [];
                        const matches = lowerText.match(regex);
                        if (matches) {
                            score = matches.length;
                            // Deduplicate keywords found from matches if needed, or just use topic.keywords for display
                            matches.forEach(match => {
                                if (!keywordsFound.includes(match.toLowerCase()) && topic.keywords.includes(match.toLowerCase())) {
                                     keywordsFound.push(match.toLowerCase());
                                }
                            });
                        }
                        
                        if (score > 0) {
                            topic.count += score;
                            topic.segments.push({ ...segment, topicRelevanceScore: score, keywordsFound: [...new Set(keywordsFound)] }); // Store unique found keywords
                        }
                    });
                });
                return topics.sort((a, b) => b.count - a.count);
            }
        };

        // ======== UI Controller Module ========
        const UIController = {
            setLoadingState(isLoading) {
                DOM.loading.classList.toggle('hidden', !isLoading);
                DOM.results.classList.toggle('hidden', isLoading);
                DOM.analyzeBtn.disabled = isLoading;
                DOM.clearBtn.disabled = isLoading; 
            },
            
            showNotification(message, type = 'info') {
                const notification = document.createElement('div');
                notification.className = `fixed bottom-4 right-4 px-6 py-3 rounded-lg shadow-lg transform opacity-0 translate-y-4 transition-all duration-300 ease-in-out z-50`;
                const typeClasses = { success: 'bg-green-600 text-white', error: 'bg-red-600 text-white', warning: 'bg-yellow-500 text-white', info: 'bg-primary text-white' };
                notification.classList.add(...(typeClasses[type] || typeClasses.info).split(' '));
                notification.textContent = message; 
                document.body.appendChild(notification);
                requestAnimationFrame(() => { notification.classList.remove('opacity-0', 'translate-y-4'); notification.classList.add('opacity-100', 'translate-y-0'); });
                setTimeout(() => {
                    notification.classList.remove('opacity-100', 'translate-y-0'); notification.classList.add('opacity-0', 'translate-y-4');
                    setTimeout(() => { if (document.body.contains(notification)) document.body.removeChild(notification); }, 300);
                }, 3000);
            },
            
            displayMeetingInfo(analysis) {
                let html = '';
                if (analysis.meetings.length > 0 && analysis.meetings[0].title !== "Transcript Analysis") { 
                    const meeting = analysis.meetings[0];
                    html = `
                        <div class="grid grid-cols-1 md:grid-cols-2 gap-4">
                            <div><p class="font-medium text-gray-700 dark:text-gray-300">Meeting Title:</p><p>${_.escape(meeting.title) || 'Unknown'}</p></div>
                            <div><p class="font-medium text-gray-700 dark:text-gray-300">Date & Time:</p><p>${_.escape(meeting.date) || 'Not specified'}</p></div>
                            <div><p class="font-medium text-gray-700 dark:text-gray-300">Meeting Type:</p><p>${_.escape(meeting.type) || 'General'}</p></div>
                            <div><p class="font-medium text-gray-700 dark:text-gray-300">Participants:</p><p>${meeting.participants?.map(_.escape).join(', ') || 'Unknown'}</p></div>
                        </div>`;
                } else {
                    html = `<p>No specific meeting information detected. Analysis performed on general transcript content.</p>`;
                }
                html += `
                    <div class="mt-4">
                        <p class="font-medium text-gray-700 dark:text-gray-300">Analysis Summary:</p>
                        <div class="grid grid-cols-1 md:grid-cols-3 gap-4 mt-2">
                            <div class="bg-gray-100 dark:bg-gray-800 p-3 rounded"><p class="text-xs uppercase text-gray-500 dark:text-gray-400">Total Segments</p><p class="text-2xl font-bold">${analysis.combinedSegments.length}</p></div>
                            <div class="bg-gray-100 dark:bg-gray-800 p-3 rounded"><p class="text-xs uppercase text-gray-500 dark:text-gray-400">Key Term Mentions</p><p class="text-2xl font-bold">${Object.values(analysis.keyTerms).reduce((a, b) => a + b, 0)}</p></div>
                            <div class="bg-gray-100 dark:bg-gray-800 p-3 rounded"><p class="text-xs uppercase text-gray-500 dark:text-gray-400">Overall Sentiment</p><p class="text-2xl font-bold ${this.getSentimentColorClass(analysis)}">${this.getOverallSentiment(analysis)}</p></div>
                        </div>
                    </div>`;
                DOM.meetingInfo.innerHTML = html;
            },
            
            getSentimentColorClass(analysis) {
                const overall = this.getOverallSentiment(analysis);
                if (overall === 'Positive') return 'text-green-600 dark:text-green-400';
                if (overall === 'Negative') return 'text-red-600 dark:text-red-400';
                return 'text-gray-600 dark:text-gray-400';
            },
            
            getOverallSentiment(analysis) {
                const { positive, negative, neutral } = analysis.sentiment;
                const total = positive + negative + neutral;
                if (total === 0) return 'Neutral';
                const posPercent = (positive / total) * 100;
                const negPercent = (negative / total) * 100;
                if (posPercent > negPercent && posPercent > (neutral / total * 100) + 10 && posPercent > 30) return 'Positive'; 
                if (negPercent > posPercent && negPercent > (neutral / total * 100) + 10 && negPercent > 30) return 'Negative';
                if (Math.abs(posPercent - negPercent) < 20 && (posPercent > 10 || negPercent > 10)) return 'Mixed'; 
                return 'Neutral'; 
            },
            
            renderTimelineView(analysis) {
                if (analysis.combinedSegments.length === 0) {
                    DOM.timelineContent.innerHTML = '<p>No segments found in the transcript.</p>'; return;
                }
                const segmentsBySource = _.groupBy(analysis.combinedSegments, 'source');
                let finalHtml = '';
                Object.entries(segmentsBySource).forEach(([source, segments]) => {
                    if (Object.keys(segmentsBySource).length > 1) {
                        finalHtml += `<div class="mb-4"><h3 class="text-lg font-medium mb-2">${_.escape(source)}</h3></div>`;
                    }
                    finalHtml += segments.map(segment => {
                        const highlightedText = this.highlightKeyTerms(_.escape(segment.text), Object.keys(analysis.keyTerms));
                        let sentimentClass = '';
                        if (segment.sentiment === 'positive') sentimentClass = 'border-l-4 border-green-500 pl-2';
                        else if (segment.sentiment === 'negative') sentimentClass = 'border-l-4 border-red-500 pl-2';
                        return `<div class="flex mb-4"><div class="flex-none text-sm font-mono w-20 text-gray-500 dark:text-gray-400 pt-1">${_.escape(segment.timestamp)}</div><div class="flex-1 pl-4 border-l-2 border-gray-300 dark:border-gray-700"><div class="pb-2 ${sentimentClass}">${highlightedText}</div></div></div>`;
                    }).join('');
                });
                DOM.timelineContent.innerHTML = finalHtml;
            },
            
            highlightKeyTerms(text, terms) {
                let highlightedText = text;
                terms.forEach(term => {
                    const regex = new RegExp(`\\b(${_.escapeRegExp(term)})\\b`, 'gi'); 
                    highlightedText = highlightedText.replace(regex, `<span class="bg-primary/20 px-1 rounded">$1</span>`);
                });
                return highlightedText;
            },
            
            renderKeywordAnalysis() {
                if (!AppState.analysis) return;
                const keyTermsData = Object.entries(AppState.analysis.keyTerms).filter(([,count]) => count > 0).sort((a, b) => b[1] - a[1]);
                const keywordsCtx = DOM.getCanvasContext('keywordsChart');
                if (AppState.charts.keywords) AppState.charts.keywords.destroy();
                
                const chartColors = { bgColor: AppState.darkMode ? '#5D5CDE80' : '#5D5CDE', borderColor: AppState.darkMode ? '#5D5CDE' : '#4A49B0', textColor: AppState.darkMode ? '#e5e7eb' : '#374151' };
                if (keyTermsData.length > 0) {
                    AppState.charts.keywords = new Chart(keywordsCtx, { type: 'bar', data: { labels: keyTermsData.map(item => item[0]), datasets: [{ label: 'Mentions', data: keyTermsData.map(item => item[1]), backgroundColor: chartColors.bgColor, borderColor: chartColors.borderColor, borderWidth: 1 }] }, options: { responsive: true, maintainAspectRatio: false, scales: { y: { beginAtZero: true, ticks: { precision: 0, color: chartColors.textColor } }, x: { ticks: { color: chartColors.textColor } } }, plugins: { legend: { labels: { color: chartColors.textColor } } } } });
                } else {
                    keywordsCtx.clearRect(0,0,keywordsCtx.canvas.width, keywordsCtx.canvas.height);
                     keywordsCtx.canvas.parentElement.innerHTML = '<canvas id="keywordsChart"></canvas><p class="text-center text-gray-500 dark:text-gray-400 p-4">No key terms found.</p>'; // Re-add canvas for next time

                }

                const wordCloudEl = document.getElementById('wordCloud');
                const topWords = Object.entries(AppState.analysis.wordFrequency).filter(([word]) => word.length > 3).sort((a, b) => b[1] - a[1]).slice(0, 50);
                const wordCloudParts = [];
                if (topWords.length > 0 && topWords[0][1] > 1) { // Ensure there's a max count > 1 for scaling
                    const maxCount = topWords[0][1];
                    const stopwords = ['and', 'the', 'to', 'of', 'in', 'is', 'that', 'it', 'with', 'as', 'for', 'on', 'are', 'was', 'we', 'you', 'he', 'she', 'they', 'this', 'what', 'but', 'not'];
                    topWords.forEach(([word, count]) => {
                        if (stopwords.includes(word) || count < 2) return; 
                        const fontSize = 12 + Math.floor((count / maxCount) * 28); 
                        const opacity = 0.6 + (count / maxCount) * 0.4;
                        const colors = ['#5D5CDE', '#4CAF50', '#FFC107', '#F44336', '#9C27B0', '#2196F3', '#FF9800'];
                        const color = colors[Math.floor(Math.random() * colors.length)];
                        const rotation = Math.floor(Math.random() * 6) * (Math.random() < 0.5 ? -1 : 1) * 5; 
                        wordCloudParts.push(`<span class="inline-block m-1.5 p-1 cursor-default" style="font-size: ${fontSize}px; opacity: ${opacity}; color: ${color}; transform: rotate(${rotation}deg); line-height: 1;">${_.escape(word)}</span>`);
                    });
                }
                wordCloudEl.innerHTML = wordCloudParts.length > 0 ? wordCloudParts.join('') : '<p class="text-center text-gray-500 p-4">Not enough data for word cloud.</p>';
                
                const termContextTableBody = document.getElementById('termContextTable');
                let tableHtml = '';
                keyTermsData.forEach(([term, count]) => {
                    const contexts = AppState.analysis.termContexts[term] || [];
                    const contextHTML = contexts.length > 0 
                        ? contexts.map(ctx => { const highlightedContext = _.escape(ctx).replace(new RegExp(`\\b(${_.escapeRegExp(term)})\\b`, 'gi'), '<span class="bg-primary/20 px-1 rounded">$1</span>'); return `<div class="mb-2 pb-2 border-b dark:border-gray-700 last:border-b-0">"${highlightedContext}"</div>`; }).join('')
                        : '<em class="text-gray-500 dark:text-gray-400">No contexts captured</em>';
                    tableHtml += `<tr class="hover:bg-gray-50 dark:hover:bg-gray-800 transition-colors duration-150"><td class="px-4 py-3 whitespace-nowrap font-medium">${_.escape(term)}</td><td class="px-4 py-3 whitespace-nowrap">${count}</td><td class="px-4 py-3">${contextHTML}</td></tr>`;
                });
                termContextTableBody.innerHTML = tableHtml || `<tr><td colspan="3" class="text-center text-gray-500 dark:text-gray-400 p-4">No key term contexts to display.</td></tr>`;
            },
            
            renderSentimentAnalysis() {
                if (!AppState.analysis) return;
                const sentimentCtx = DOM.getCanvasContext('sentimentChart');
                if (AppState.charts.sentiment) AppState.charts.sentiment.destroy();
                const chartColors = { positive: '#4CAF50', negative: '#F44336', neutral: '#9E9E9E', textColor: AppState.darkMode ? '#e5e7eb' : '#374151' };
                const {positive, negative, neutral} = AppState.analysis.sentiment;

                if (positive + negative + neutral > 0) {
                    AppState.charts.sentiment = new Chart(sentimentCtx, { type: 'doughnut', data: { labels: ['Positive', 'Negative', 'Neutral'], datasets: [{ data: [ positive, negative, neutral ], backgroundColor: [ chartColors.positive + (AppState.darkMode ? '90' : 'CC'), chartColors.negative + (AppState.darkMode ? '90' : 'CC'), chartColors.neutral + (AppState.darkMode ? '90' : 'CC') ], borderColor: [ chartColors.positive, chartColors.negative, chartColors.neutral ], borderWidth: 1 }] }, options: { responsive: true, maintainAspectRatio: false, plugins: { legend: { position: 'right', labels: { color: chartColors.textColor, padding: 20 } }, tooltip: { callbacks: { label: function(context) { const total = context.dataset.data.reduce((a,b)=>a+b,0); const value = context.parsed; const percentage = total ? Math.round((value/total)*100) : 0; return `${context.label}: ${value} (${percentage}%)`; } } } } } });
                } else {
                     sentimentCtx.clearRect(0,0,sentimentCtx.canvas.width, sentimentCtx.canvas.height);
                     sentimentCtx.canvas.parentElement.innerHTML = '<canvas id="sentimentChart"></canvas><p class="text-center text-gray-500 dark:text-gray-400 p-4">No sentiment data to display.</p>';
                }


                const sentimentTimelineCtx = DOM.getCanvasContext('sentimentTimelineChart');
                if (AppState.charts.sentimentTimeline) AppState.charts.sentimentTimeline.destroy();
                const sentimentData = []; const labels = [];
                if (AppState.analysis.combinedSegments.length > 0) {
                    const chunkSize = Math.max(1, Math.ceil(AppState.analysis.combinedSegments.length / 15)); 
                    for (let i = 0; i < AppState.analysis.combinedSegments.length; i += chunkSize) {
                        const chunk = AppState.analysis.combinedSegments.slice(i, i + chunkSize);
                        sentimentData.push({ positive: chunk.filter(s => s.sentiment === 'positive').length, negative: chunk.filter(s => s.sentiment === 'negative').length });
                        if (chunk[0]?.timestamp && chunk[0].timestamp !== '00:00') labels.push(chunk[0].timestamp); else labels.push(`Part ${Math.floor(i / chunkSize) + 1}`);
                    }
                }
                if (sentimentData.length > 0) {
                    AppState.charts.sentimentTimeline = new Chart(sentimentTimelineCtx, { type: 'line', data: { labels: labels, datasets: [ { label: 'Positive', data: sentimentData.map(d => d.positive), borderColor: chartColors.positive, backgroundColor: chartColors.positive + '20', borderWidth: 2, tension: 0.3, fill: true }, { label: 'Negative', data: sentimentData.map(d => d.negative), borderColor: chartColors.negative, backgroundColor: chartColors.negative + '20', borderWidth: 2, tension: 0.3, fill: true } ] }, options: { responsive: true, maintainAspectRatio: false, scales: { y: { beginAtZero: true, ticks: { precision: 0, color: chartColors.textColor } }, x: { ticks: { color: chartColors.textColor } } }, plugins: { legend: { labels: { color: chartColors.textColor } }, tooltip: { callbacks: { title: function(context){ return `Segment: ${context[0].label}`; } } } }, interaction: { mode: 'index', intersect: false } } });
                } else {
                    sentimentTimelineCtx.clearRect(0,0,sentimentTimelineCtx.canvas.width, sentimentTimelineCtx.canvas.height);
                    sentimentTimelineCtx.canvas.parentElement.innerHTML = '<canvas id="sentimentTimelineChart"></canvas><p class="text-center text-gray-500 dark:text-gray-400 p-4">No sentiment timeline data.</p>';
                }
                
                const emotionalToneEl = document.getElementById('emotionalToneAnalysis');
                const toneCounts = {}; Object.keys(AppState.emotionalTones).forEach(tone => { toneCounts[tone] = 0; });
                const precompiledToneRegexes = {};
                Object.entries(AppState.emotionalTones).forEach(([tone, keywords]) => { if (keywords.length > 0) precompiledToneRegexes[tone] = new RegExp(`\\b(${keywords.map(_.escapeRegExp).join('|')})\\b`, 'gi'); });
                AppState.analysis.combinedSegments.forEach(segment => {
                    const lowerText = segment.text.toLowerCase();
                    Object.entries(precompiledToneRegexes).forEach(([tone, regex]) => { if (regex) { const matches = lowerText.match(regex); if (matches) toneCounts[tone] += matches.length; } });
                });
                const maxToneCount = Math.max(...Object.values(toneCounts), 1);
                let emotionalToneHtml = '';
                Object.entries(toneCounts).forEach(([tone, count]) => {
                    if (count === 0) return; // Only show tones that are present
                    const toneColors = { Collaborative: '#4CAF50', Instructional: '#2196F3', Concerned: '#F44336', Structured: '#9C27B0' };
                    const toneColor = toneColors[tone] || '#5D5CDE'; const percentage = Math.min(Math.round((count / maxToneCount) * 100), 100);
                    emotionalToneHtml += `<div class="bg-white dark:bg-gray-800 p-4 rounded-lg shadow-sm transition-all duration-200 hover:shadow-md"><div class="flex justify-between items-center mb-2"><h4 class="font-medium">${_.escape(tone)} Tone</h4><span class="text-sm font-mono bg-gray-100 dark:bg-gray-700 px-2 py-1 rounded">${count}</span></div><div class="w-full bg-gray-200 dark:bg-gray-700 rounded-full h-2.5 mb-3"><div class="h-2.5 rounded-full" style="width: ${percentage}%; background-color: ${toneColor};"></div></div><p class="text-sm text-gray-600 dark:text-gray-400"><span class="font-medium">Keywords:</span> ${AppState.emotionalTones[tone].slice(0, 4).map(_.escape).join(', ')}${AppState.emotionalTones[tone].length > 4 ? '...' : ''}</p></div>`;
                });
                emotionalToneEl.innerHTML = emotionalToneHtml || '<p class="col-span-full text-center text-gray-500 dark:text-gray-400 p-4">No prominent emotional tones detected.</p>';
            },
            
            renderTopicAnalysis() {
                if (!AppState.analysis) return;
                const topicsCtx = DOM.getCanvasContext('topicsChart');
                if (AppState.charts.topics) AppState.charts.topics.destroy();
                const chartColors = { textColor: AppState.darkMode ? '#e5e7eb' : '#374151' };
                const filteredTopics = AppState.analysis.topicClusters.filter(topic => topic.count > 0);

                if (filteredTopics.length > 0) {
                    const topicColors = filteredTopics.map(topic => topic.color);
                    AppState.charts.topics = new Chart(topicsCtx, { type: 'bar', data: { labels: filteredTopics.map(topic => topic.name), datasets: [{ label: 'Mentions', data: filteredTopics.map(topic => topic.count), backgroundColor: topicColors.map(color => color + (AppState.darkMode ? '80' : 'CC')), borderColor: topicColors, borderWidth: 1 }] }, options: { responsive: true, maintainAspectRatio: false, indexAxis: 'y', scales: { y: { ticks: { color: chartColors.textColor } }, x: { beginAtZero: true, ticks: { precision: 0, color: chartColors.textColor } } }, plugins: { legend: { display: false }, tooltip: { callbacks: { label: function(context){ return `${context.parsed.x} mentions`; } } } } } });
                } else {
                    topicsCtx.clearRect(0,0,topicsCtx.canvas.width, topicsCtx.canvas.height);
                    topicsCtx.canvas.parentElement.innerHTML = '<canvas id="topicsChart"></canvas><p class="text-center text-gray-500 dark:text-gray-400 p-4">No topics identified.</p>';
                }
                
                this.renderTopicNetwork();
                
                const topicDetailsEl = document.getElementById('topicDetails');
                let topicDetailsHtml = '';
                if (filteredTopics.length > 0) {
                    const maxTopicCount = Math.max(...filteredTopics.map(t => t.count), 1);
                    filteredTopics.forEach(topic => {
                        const sampleSegments = [...topic.segments].sort((a, b) => b.topicRelevanceScore - a.topicRelevanceScore).slice(0, 3);
                        const segmentsHTML = sampleSegments.map(segment => { let highlightedText = _.escape(segment.text); segment.keywordsFound.forEach(keyword => { const regex = new RegExp(`\\b(${_.escapeRegExp(keyword)})\\b`, 'gi'); highlightedText = highlightedText.replace(regex, `<span style="background-color: ${topic.color}30; padding: 0 4px; border-radius: 4px;">$1</span>`); }); return `<div class="mb-2 pb-2 border-b dark:border-gray-700 text-sm last:border-b-0"><div class="text-gray-500 dark:text-gray-400 text-xs flex justify-between"><span>${_.escape(segment.timestamp)}</span><span>Relevance: ${segment.topicRelevanceScore}</span></div>"${highlightedText}"</div>`; }).join('');
                        const percentage = Math.round((topic.count / maxTopicCount) * 100);
                        topicDetailsHtml += `<div class="bg-white dark:bg-gray-800 p-4 rounded-lg shadow-sm transition-all duration-200 hover:shadow-md"><div style="border-left: 4px solid ${topic.color}; padding-left: 10px;"><h4 class="font-medium mb-2">${_.escape(topic.name)}</h4><div class="flex items-center mb-3"><div class="w-full bg-gray-200 dark:bg-gray-700 rounded-full h-2.5"><div class="h-2.5 rounded-full" style="width: ${percentage}%; background-color: ${topic.color};"></div></div><span class="ml-2 text-sm">${topic.count} mentions</span></div><p class="text-sm mb-2 text-gray-600 dark:text-gray-400"><span class="font-medium">Keywords:</span> ${topic.keywords.map(_.escape).join(', ')}</p><div class="mt-3"><p class="text-sm font-medium mb-1">Representative mentions:</p>${segmentsHTML || '<p class="text-sm italic text-gray-500 dark:text-gray-400">No representative mentions found</p>'}</div></div></div>`;
                    });
                }
                topicDetailsEl.innerHTML = topicDetailsHtml || '<p class="text-center text-gray-500 dark:text-gray-400 p-4">No topic details to display.</p>';
            },
            
            renderTopicNetwork() {
                const topicNetworkEl = document.getElementById('topicNetwork');
                const topics = AppState.analysis.topicClusters.filter(t => t.count > 0); 
                if (topics.length === 0) {
                    topicNetworkEl.innerHTML = '<p class="text-center text-gray-500 dark:text-gray-400 p-4">No topic relationships to display.</p>'; return;
                }
                const svgParts = [];
                svgParts.push(`<svg viewBox="0 0 400 400" class="w-full h-full">`);
                const centralNodeColor = AppState.darkMode ? '#5D5CDEB0' : '#5D5CDE';
                svgParts.push(`<circle cx="200" cy="200" r="30" fill="${centralNodeColor}" /><text x="200" y="205" text-anchor="middle" fill="white" font-size="10" class="font-semibold">Focus</text>`);
                const totalTopics = topics.length; const maxCountAllTopics = Math.max(...topics.map(t => t.count || 1), 1);
                topics.forEach((topic, index) => {
                    const angle = (2 * Math.PI * index) / totalTopics; const radius = 120; 
                    const x = 200 + radius * Math.cos(angle); const y = 200 + radius * Math.sin(angle);
                    const minSize = 15; const maxSize = 30; 
                    const size = minSize + ((topic.count / maxCountAllTopics) * (maxSize - minSize));
                    svgParts.push(`<circle cx="${x}" cy="${y}" r="${size}" fill="${topic.color}${AppState.darkMode ? 'B0' : ''}" />`);
                    svgParts.push(`<text x="${x}" y="${y + 4}" text-anchor="middle" fill="${AppState.darkMode ? '#FFF' : '#374151'}" font-size="9" class="font-medium">${_.escape(topic.name.split(' ')[0])}</text>`);
                    svgParts.push(`<line x1="200" y1="200" x2="${x}" y2="${y}" stroke-width="${Math.max(1, 2 + (topic.count / maxCountAllTopics) * 3)}" stroke="${topic.color}80" />`);
                });
                svgParts.push('</svg>');
                topicNetworkEl.innerHTML = svgParts.join('');
            },
            countSharedMentions(topic1, topic2) { /* Unused */ return 0;}
        };

        // ======== Data Export Module ========
        const DataExporter = {
            downloadAnalysisJSON(analysis) {
                const exportData = { meetings: analysis.meetings, analysis: { keyTerms: analysis.keyTerms, sentiment: analysis.sentiment, topicClusters: analysis.topicClusters.map(topic => ({ name: topic.name, keywords: topic.keywords, count: topic.count })) }, segments: analysis.combinedSegments.map(segment => ({ source: segment.source, text: segment.text, timestamp: segment.timestamp, sentiment: segment.sentiment })) };
                const dataStr = "data:text/json;charset=utf-8," + encodeURIComponent(JSON.stringify(exportData, null, 2));
                const dl = document.createElement('a'); dl.setAttribute("href", dataStr); dl.setAttribute("download", "transcript_analysis.json"); document.body.appendChild(dl); dl.click(); dl.remove();
            },
            generateTextReport(analysis) {
                let report = `MEETING TRANSCRIPT ANALYSIS\n=============================================\n\n`;
                if (analysis.meetings.length > 0 && analysis.meetings[0].title !== "Transcript Analysis") { const m = analysis.meetings[0]; report += `Meeting: ${m.title || 'Unknown'}\nDate: ${m.date || 'Not specified'}\nType: ${m.type || 'General'}\n`; if (m.participants && m.participants.length) report += `Participants: ${m.participants.join(', ')}\n`; report += `\n`; }
                report += `SUMMARY STATISTICS\n---------------------------------------------\n`;
                report += `Total Segments Analyzed: ${analysis.combinedSegments.length}\nKey Term Mentions: ${Object.values(analysis.keyTerms).reduce((a,b)=>a+b,0)}\n`;
                report += `Overall Sentiment: ${UIController.getOverallSentiment(analysis)}\n  - Positive Segments: ${analysis.sentiment.positive}\n  - Negative Segments: ${analysis.sentiment.negative}\n  - Neutral Segments: ${analysis.sentiment.neutral}\n\n`;
                report += `KEY TERMS\n---------------------------------------------\n`;
                Object.entries(analysis.keyTerms).sort((a,b)=>b[1]-a[1]).forEach(([t,c])=>{if(c>0)report+=`${t}: ${c} mentions\n`;});
                report += `\nMAIN TOPICS\n---------------------------------------------\n`;
                analysis.topicClusters.filter(tp=>tp.count>0).forEach(tp=>{report+=`${tp.name}: ${tp.count} mentions\nKeywords: ${tp.keywords.join(', ')}\n\n`;});
                return report;
            }
        };

        document.addEventListener('DOMContentLoaded', () => EventHandlers.init());
    </script>
</body>
</html>